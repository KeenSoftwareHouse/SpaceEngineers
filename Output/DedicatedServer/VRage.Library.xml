<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VRage.Library</name>
    </assembly>
    <members>
        <member name="M:VRage.Algorithms.IMyPathEdge`1.GetOtherVertex(`0)">
            <summary>
            Returns the other vertex on this edge.
            Can return null, if the edge is a loop or if the edge is not traversable
            </summary>
        </member>
        <member name="M:VRage.Algorithms.IMyPathVertex`1.EstimateDistanceTo(VRage.Algorithms.IMyPathVertex{`0})">
            <summary>
            Heuristic on the shortest path to another vertex. Used for finding the shortest path.
            </summary>
        </member>
        <member name="M:VRage.Algorithms.IMyPathVertex`1.GetNeighborCount">
            <summary>
            Returns the number of neighbouring vertices.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VRage.Algorithms.IMyPathVertex`1.GetNeighbor(System.Int32)" -->
        <member name="M:VRage.Algorithms.IMyPathVertex`1.GetEdge(System.Int32)">
            <summary>
            Gets N-th edge of this vertex.
            Must be consistent with the GetNeighbor() function.
            </summary>
        </member>
        <member name="M:VRage.Algorithms.MyPathFindingSystem`1.PrepareTraversal(`0,System.Predicate{`0},System.Predicate{`0},System.Predicate{VRage.Algorithms.IMyPathEdge{`0}})">
            <summary>
            Has to be called before any traversal of the pathfinding system using enumerators.
            
            Several predicates can be supplied to the system that change the behavior of the traversal.
            </summary>
            <param name="startingVertex">The vertex from which the traversal starts</param>
            <param name="vertexFilter">If set, this predicate is applied to the output vertices so that we only get those that we are interested in.</param>
            <param name="vertexTraversable">
                This predicate allows to make vertices of the graph untraversable, blocking the paths through them.
                It is guaranteed to be called only once on every vertex when enumerating the graph or finding reachable vertices, but
                for pathfinding functions, this guarantee is no longer valid.
            </param>
            <param name="edgeTraversable">This predicate allows to make edges untraversable, blocking the paths through them.</param>
        </member>
        <member name="T:VRage.Collections.CachingDictionary`2">
            <summary>
            Dictionary wrapper that allows for addition and removal even during enumeration.
            Done by caching changes and allowing explicit application using Apply* methods.
            </summary>
        </member>
        <member name="T:VRage.Collections.CachingList`1">
            <summary>
            List wrapper that allows for addition and removal even during enumeration.
            Done by caching changes and allowing explicit application using Apply* methods.
            </summary>
        </member>
        <member name="T:VRage.Collections.MyIntervalList">
            <summary>
            <para>A set of integer numbers optimized for sets with long consecutive runs. Each interval is stored as two values in m_list: the lower and the upper bound.</para>
            <para>For example, the set of numbers 2, 3, 4, 5, 7, 9, 10, 11, 12, 13 (or alternatively in the interval notation &lt;2, 5&gt; U &lt;7, 7&gt; U &lt;9, 13&gt;)
            is saved as a list { 2, 5, 7, 7, 9, 13 }</para>
            </summary>
        </member>
        <member name="M:VRage.Collections.MyIntervalList.Add(System.Int32)">
            <summary>
            Add a value to the list
            </summary>
        </member>
        <member name="M:VRage.Collections.MySinglyLinkedList`1.Split(VRage.Collections.MySinglyLinkedList{`0}.Enumerator,System.Int32)">
            <summary>
            Splits the list into two.
            This list's end will be the node pointed by newLastPosition and the newly created list will begin with the next node.
            </summary>
            <param name="newLastPosition">Enumerator that points to the new last position in the list.</param>
            <param name="newCount">New number of elements in this list. If set to -1, it is calculated automatically,
            but that would make the split an O(N) operation. Beware: If you set this parameter, be sure to always set the
            correct number, otherwise, you'd cause both lists (this one and the returned one) to return a wrong number of
            elements in the future.</param>
            <returns>The newly created list</returns>
        </member>
        <member name="T:VRage.Collections.MySwapQueue`1">
            <summary>
            Holds three objects in safe manner, use when Reader requires only last valid data.
            One object is used for reading, one for writing and third is used as buffer, so reader/writer don't have to wait on the other.
            </summary>
        </member>
        <member name="M:VRage.Collections.MySwapQueue`1.RefreshRead">
            <summary>
            Updates data for reading if there's something new
            Returns true when Read was updated, returns false when Read was not changed
            </summary>
        </member>
        <member name="M:VRage.Collections.MySwapQueue`1.CommitWrite">
            <summary>
            Commits Write and replaces write with new object ready for new writing
            </summary>
        </member>
        <member name="T:VRage.InstanceComparer`1">
            <summary>
            Most probably fastest possible comparer which compares instances of objects
            </summary>
        </member>
        <member name="T:VRage.Collections.MyCommitQueue`1">
            <summary>
            Basic copy-on-commit implementation, later it will be faster by using one queue with 2 tails
            </summary>
        </member>
        <member name="T:VRage.Collections.MyQueue`1">
            <summary>
            Allows access to queue by index
            Otherwise implementation is similar to regular queue
            </summary>
        </member>
        <member name="M:VRage.Collections.MyUniqueList`1.Add(`0)">
            <summary>
            O(1)
            </summary>
        </member>
        <member name="M:VRage.Collections.MyUniqueList`1.Insert(System.Int32,`0)">
            <summary>
            O(n)
            </summary>
        </member>
        <member name="M:VRage.Collections.MyUniqueList`1.Remove(`0)">
            <summary>
            O(n)
            </summary>
        </member>
        <member name="M:VRage.Collections.MyUniqueList`1.Contains(`0)">
            <summary>
            O(1)
            </summary>
        </member>
        <member name="P:VRage.Collections.MyUniqueList`1.Count">
            <summary>
            O(1)
            </summary>
        </member>
        <member name="P:VRage.Collections.MyUniqueList`1.Item(System.Int32)">
            <summary>
            O(1)
            </summary>
        </member>
        <member name="P:VRage.Serialization.SerializableDictionary`2.Dictionary">
            <summary>
            Public stuff dictionary.
            </summary>
            <remarks>
            Note the XmlIgnore attribute.
            </remarks>
        </member>
        <member name="P:VRage.Serialization.SerializableDictionary`2.DictionaryEntryProp">
            <summary>
            Property created expressly for the XmlSerializer
            </summary>
            <remarks>
            Note the XML Serialiazation attributes; they control what elements are named when this object is serialized.
            </remarks>
        </member>
        <member name="P:VRage.Serialization.SerializableDictionaryCompat`3.DictionaryEntryProp">
            <summary>
            Property created expressly for the XmlSerializer
            </summary>
            <remarks>
            Note the XML Serialiazation attributes; they control what elements are named when this object is serialized.
            </remarks>
        </member>
        <member name="T:VRage.Compression.MyZipArchive">
            <summary>
            Class based on http://www.codeproject.com/Articles/209731/Csharp-use-Zip-archives-without-external-libraries.
            </summary>
        </member>
        <member name="M:VRage.Cryptography.MySHA256.Create">
            <summary>
            Creates FIPS compliant crypto provider if available, otherwise pure managed implementation.
            </summary>
        </member>
        <member name="F:DShowNET.Clsid.FilterGraph">
            <summary> CLSID_FilterGraph, filter Graph </summary>
        </member>
        <member name="F:DShowNET.Clsid.SampleGrabber">
            <summary> CLSID_SampleGrabber, Sample Grabber filter </summary>
        </member>
        <member name="T:DShowNET.VideoState">
            <summary>
            Describes the state of a video player
            </summary>
        </member>
        <member name="T:DShowNET.VideoPlayer">
            <summary>
            Enables Video Playback in Microsoft XNA
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.m_graphBuilder">
            <summary>
            The GraphBuilder interface ref
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.m_mediaControl">
            <summary>
            The MediaControl interface ref
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.m_mediaEvent">
            <summary>
            The MediaEvent interface ref
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.m_mediaPosition">
            <summary>
            The MediaPosition interface ref
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.m_mediaSeeking">
            <summary>
            The MediaSeeking interface ref
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.filename">
            <summary>
            The Video File to play
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.m_videoDataRgba">
            <summary>
            The RGBA frame bytes used to set the data in the Texture2D Output Frame
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.videoWidth">
            <summary>
            Private Video Width
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.videoHeight">
            <summary>
            Private Video Height
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.avgTimePerFrame">
            <summary>
            Average Time per Frame in milliseconds
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.bitRate">
            <summary>
            BitRate of the currently loaded video
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.currentState">
            <summary>
            Current state of the video player
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.isDisposed">
            <summary>
            Is Disposed?
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.currentPosition">
            <summary>
            Current time position
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.videoDuration">
            <summary>
            Video duration
            </summary>
        </member>
        <member name="F:DShowNET.VideoPlayer.alphaTransparency">
            <summary>
            How transparent the video frame is.
            Takes effect on the next frame after this is updated
            Max Value: 255 - Opaque
            Min Value: 0   - Transparent
            </summary>
        </member>
        <member name="M:DShowNET.VideoPlayer.#ctor(System.String)">
            <summary>
            Creates a new Video Player. Automatically creates the required Texture2D on the specificied GraphicsDevice.
            </summary>
            <param name="FileName">The video file to open</param>
            <param name="graphicsDevice">XNA Graphics Device</param>
        </member>
        <member name="M:DShowNET.VideoPlayer.InitInterfaces">
            <summary>
            Initialises DirectShow interfaces
            </summary>
        </member>
        <member name="M:DShowNET.VideoPlayer.CloseInterfaces">
            <summary>
            Closes DirectShow interfaces
            </summary>
        </member>
        <member name="M:DShowNET.VideoPlayer.Update">
            <summary>
            Updates the Output Frame data using data from the video stream. Call this in Game.Update().
            </summary>
        </member>
        <member name="M:DShowNET.VideoPlayer.Play">
            <summary>
            Starts playing the video
            </summary>
        </member>
        <member name="M:DShowNET.VideoPlayer.Pause">
            <summary>
            Pauses the video
            </summary>
        </member>
        <member name="M:DShowNET.VideoPlayer.Stop">
            <summary>
            Stops playing the video
            </summary>
        </member>
        <member name="M:DShowNET.VideoPlayer.Rewind">
            <summary>
            Rewinds the video to the start and plays it again
            </summary>
        </member>
        <member name="M:DShowNET.VideoPlayer.BufferCB(System.Double,System.IntPtr,System.Int32)">
            <summary>
            Required public callback from DirectShow SampleGrabber. Do not call this method.
            </summary>
        </member>
        <member name="M:DShowNET.VideoPlayer.SampleCB(System.Double,DShowNET.IMediaSample)">
            <summary>
            Required public callback from DirectShow SampleGrabber. Do not call this method.
            </summary>
        </member>
        <member name="M:DShowNET.VideoPlayer.Dispose">
            <summary>
            Cleans up the Video Player. Must be called when finished with the player.
            </summary>
        </member>
        <member name="P:DShowNET.VideoPlayer.VideoWidth">
            <summary>
            Width of the loaded video
            </summary>
        </member>
        <member name="P:DShowNET.VideoPlayer.VideoHeight">
            <summary>
            Height of the loaded video
            </summary>
        </member>
        <member name="P:DShowNET.VideoPlayer.CurrentPosition">
            <summary>
            Gets or Sets the current position of playback in seconds
            </summary>
        </member>
        <member name="P:DShowNET.VideoPlayer.CurrentPositionAsTimeString">
            <summary>
            Returns the current position of playback, formatted as a time string (HH:MM:SS)
            </summary>
        </member>
        <member name="P:DShowNET.VideoPlayer.Duration">
            <summary>
            Total duration in seconds
            </summary>
        </member>
        <member name="P:DShowNET.VideoPlayer.DurationAsTimeString">
            <summary>
            Returns the duration of the video, formatted as a time string (HH:MM:SS)
            </summary>
        </member>
        <member name="P:DShowNET.VideoPlayer.FileName">
            <summary>
            Currently Loaded Video File
            </summary>
        </member>
        <member name="P:DShowNET.VideoPlayer.CurrentState">
            <summary>
            Gets or Sets the current state of the video player
            </summary>
        </member>
        <member name="P:DShowNET.VideoPlayer.IsDisposed">
            <summary>
            Is Disposed?
            </summary>
        </member>
        <member name="P:DShowNET.VideoPlayer.FramesPerSecond">
            <summary>
            Number of Frames Per Second in the video file.
            Returns -1 if this cannot be calculated.
            </summary>
        </member>
        <member name="P:DShowNET.VideoPlayer.MillisecondsPerFrame">
            <summary>
            The number of milliseconds between each frame
            Returns -1 if this cannot be calculated
            </summary>
        </member>
        <member name="P:DShowNET.VideoPlayer.AlphaTransparency">
            <summary>
            Gets or sets how transparent the video frame is.
            Takes effect on the next frame after this is updated
            Max Value: 255 - Opaque
            Min Value: 0   - Transparent
            </summary>
        </member>
        <member name="M:System.DoubleExtensions.IsValid(System.Double)">
            <summary>
            Returns true if double is valid
            </summary>
        </member>
        <member name="M:System.FloatExtensions.IsValid(System.Single)">
            <summary>
            Returns true if float is not NaN or infinity.
            </summary>
        </member>
        <member name="M:VRage.Groups.IGroupData`1.OnCreate">
            <summary>
            Group is taken from pool
            </summary>
        </member>
        <member name="M:VRage.Groups.IGroupData`1.OnRelease">
            <summary>
            Group is returned to pool
            </summary>
        </member>
        <member name="M:VRage.Groups.IGroupData`1.OnNodeAdded(`0)">
            <summary>
            Node is added to group
            </summary>
        </member>
        <member name="M:VRage.Groups.IGroupData`1.OnNodeRemoved(`0)">
            <summary>
            Node is removed from group
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.AddNode(`0)">
            <summary>
            Adds node, asserts when node already exists
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.RemoveNode(`0)">
            <summary>
            Removes node, asserts when node is not here or node has some existing links
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.CreateLink(System.Int64,`0,`0)">
            <summary>
            Creates link between parent and child.
            Parent is owner of constraint.
            LinkId must be unique only for parent, for grid it can be packed position of block which created constraint.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.BreakLink(System.Int64,`0,`0)">
            <summary>
            Breaks link between parent and child, you can set child to null to find it by linkId.
            Returns true when link was removed, returns false when link was not found.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.LinkExists(System.Int64,`0,`0)">
            <summary>
            Returns true if the given link between parent and child exists, you can set child to null to find it by linkId.
            </summary>
        </member>
        <member name="F:VRage.Groups.MyGroups`2.SupportsOphrans">
            <summary>
            When true, groups with one member are supported.
            You can use AddNode and RemoveNode.
            You have to manually call RemoveNode!
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.#ctor(System.Boolean,VRage.Groups.MyGroups{`0,`1}.MajorGroupComparer)">
            <summary>
            Initializes a new instance of MyGroups class.
            </summary>
            <param name="supportOphrans">When true, groups with one member are supported and you have to manually call RemoveNode!</param>
            <param name="groupSelector">Major group selector, when merging two groups, major group is preserved. By default it's larger group.</param>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.AddNode(`0)">
            <summary>
            Adds node, asserts when node already exists
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.RemoveNode(`0)">
            <summary>
            Removes node, asserts when node is not here or node has some existing links
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.CreateLink(System.Int64,`0,`0)">
            <summary>
            Creates link between parent and child.
            Parent is owner of constraint.
            LinkId must be unique for parent and for child; LinkId is unique node-node identifier.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.BreakLink(System.Int64,`0,`0)">
            <summary>
            Breaks link between parent and child, you can set child to null to find it by linkId.
            Returns true when link was removed, returns false when link was not found.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.TryReleaseNode(VRage.Groups.MyGroups{`0,`1}.Node)">
            <summary>
            Returns true when node was released completely and returned to pool.
            </summary>
        </member>
        <member name="T:VRage.Groups.MyGroups`2.MajorGroupComparer">
            <summary>
            Return true when "major" is really major group, otherwise false.
            </summary>
        </member>
        <member name="T:VRage.Compression.MyStreamWrapper">
            <summary>
            Stream wrapper which will close both stream and other IDisposable object
            </summary>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.GenerateKeys(System.Byte[]@,System.Byte[]@)">
            <summary>
            Generate keys into specified files.
            </summary>
            <param name="publicKeyFileName">Name of the file that will contain public key</param>
            <param name="privateKeyFileName">Name of the file that will contain private key</param>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.SignData(System.String,System.String)">
            <summary>
            Signs given data with provided key.
            </summary>
            <param name="data">data to sign (in base64 form)</param>
            <param name="privateKey">private key (in base64 form)</param>
            <returns>Signed data (string in base64 form)</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.SignHash(System.Byte[],System.Byte[])">
            <summary>
            Signs given hash with provided key.
            </summary>
            <param name="hash">hash to sign</param>
            <param name="privateKey">private key</param>
            <returns>Signed hash (string in base64 form)</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.SignHash(System.String,System.String)">
            <summary>
            Signs given hash with provided key.
            </summary>
            <param name="hash">hash to sign (in base64 form)</param>
            <param name="privateKey">private key (in base64 form)</param>
            <returns>Signed hash (string in base64 form)</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.VerifyHash(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verifies that a digital signature is valid by determining the hash value
            in the signature using the provided public key and comparing it to the provided hash value.
            </summary>
            <param name="hash">hash to test</param>
            <param name="signedHash">already signed hash</param>
            <param name="publicKey">signature</param>
            <returns>true if the signature is valid; otherwise, false.</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.VerifyHash(System.String,System.String,System.String)">
            <summary>
            Verifies that a digital signature is valid by determining the hash value
            in the signature using the provided public key and comparing it to the provided hash value.
            </summary>
            <param name="hash">hash to test</param>
            <param name="signedHash">already signed hash (in base64 form)</param>
            <param name="publicKey">signature (in base64 form)</param>
            <returns>true if the signature is valid; otherwise, false.</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.VerifyData(System.String,System.String,System.String)">
            <summary>
            Verifies that a digital signature is valid by determining the hash value
            in the signature using the provided public key and comparing it to the hash value of the provided data.
            </summary>
            <param name="originalMessage">original data</param>
            <param name="signedMessage">signed message (in base64 form)</param>
            <param name="publicKey">signature (in base64 form)</param>
            <returns>true if the signature is valid; otherwise, false.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.CompilerHelper.GetCallerFileName(System.String)">
            <summary>
            Helper method which returns file path of caller.
            </summary>
        </member>
        <member name="M:VRage.Compiler.IlChecker.CheckIl(System.Collections.Generic.List{VRage.Compiler.IlReader.IlInstruction},System.Type@,System.Boolean,System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{System.Reflection.MemberInfo}})">
            <summary>
            Checks list of IL instructions against dangerous types
            </summary>
            <param name="dangerousTypeNames">Full names of dangerous types</param>
        </member>
        <member name="T:VRage.Compiler.IlReader">
            <summary>
            Reads method body and returns instructions
            </summary>
        </member>
        <member name="T:VRage.Compiler.TypeNameHelper`1">
            <summary>
            Type name which does not make allocations
            </summary>
        </member>
        <member name="M:System.ArrayExtensions.OfTypeFast``2(``0[])">
            <summary>
            OfType on array implemented without allocations
            </summary>
        </member>
        <member name="M:VRage.Extensions.ArrayOfTypeEnumerator`3.GetEnumerator">
            <summary>
            So we can put this into foreach
            </summary>
        </member>
        <member name="M:System.Net.IPAddressExtensions.TryParseEndpoint(System.String,System.Net.IPEndPoint@)">
            <summary>
            Parses IP Endpoint from string in format x.x.x.x:port
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.RemoveAtFast``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Remove element at index by replacing it with last element in list.
            Removing is very fast but it breaks order of items in list!
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">The list.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.Move``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>
            Moves item in the list from original index to target index, reordering elements as if Remove and Insert was called.
            However, only elements in the range between the two indices are affected.
            </summary>
        </member>
        <member name="M:System.StreamExtensions.UnwrapGZip(System.IO.Stream)">
            <summary>
            Checks for GZip header and if found, returns decompressed Stream, otherwise original Stream
            </summary>
        </member>
        <member name="M:System.StreamExtensions.WrapGZip(System.IO.Stream,System.Boolean)">
            <summary>
            Wraps stream into GZip compression stream resulting in writing compressed stream
            </summary>
        </member>
        <member name="M:System.StreamExtensions.WriteNoAlloc(System.IO.Stream,System.String,System.Text.Encoding)">
            <summary>
            Writes byte count prefixed encoded text into the file. Byte count is written as 7-bit encoded 32-bit int.
            If no encoding is specified, UTF-8 will be used. Byte count prefix specifies number of bytes taken up by
            the string, not length of the string itself.
            Note that this method may allocate if the size of encoded string exceeds size of prepared buffer.
            </summary>
        </member>
        <member name="M:System.Text.StringBuilderExtensions.CompareUpdate(System.Text.StringBuilder,System.String)">
            <summary>
            Compares string builder with text,
            when it's different, Clears string builder and Appends text.
            Returns true when original string builder was modified.
            </summary>
        </member>
        <member name="M:System.Text.StringBuilderExtensions.CompareUpdate(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Compares string builder with text,
            when it's different, Clears string builder and Appends text.
            Returns true when original string builder was modified.
            </summary>
        </member>
        <member name="M:System.Text.StringBuilderExtensions.TrimEnd(System.Text.StringBuilder,System.Int32)">
            <summary>
            Removes the specified number of characters from the end.
            </summary>
            <param name="sb">The sb.</param>
            <param name="length">The length.</param>
        </member>
        <member name="M:System.Text.StringBuilderExtensions.TrimTrailingWhitespace(System.Text.StringBuilder)">
            <summary>
            Removes whitespace from the end.
            </summary>
        </member>
        <member name="M:VRage.FileSystem.IFileProvider.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Opens file, returns null when file does not exists
            </summary>
        </member>
        <member name="M:VRage.FileSystem.IFileProvider.DirectoryExists(System.String)">
            <summary>
            True if directory exists
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.IFileProvider.GetFiles(System.String,System.String,VRage.FileSystem.MySearchOption)">
            <summary>
            Returns list of files in directory
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.IFileProvider.FileExists(System.String)">
            <summary>
            True if file exists
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.MyFileProviderAggregator.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Opens file, returns null when file does not exists or cannot be opened
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyZipFileProvider.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            FileShare is ignored
            Usage: C:\Users\Data\Archive.zip\InnerFolder\file.txt
            </summary>
        </member>
        <member name="M:KeenSoftwareHouse.Library.IO.Win32Processes.GetProcessesLockingFile(System.String)">
            <summary>
            Return a list of processes that hold on the given file.
            </summary>
        </member>
        <member name="M:KeenSoftwareHouse.Library.IO.Win32Processes.GetFilesLockedBy(System.Diagnostics.Process)">
            <summary>
            Return a list of file locks held by the process.
            </summary>
        </member>
        <member name="M:VRage.ResetableMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Original C# implementation
            </summary>
        </member>
        <member name="M:VRage.ResetableMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Original C# implementation
            </summary>
        </member>
        <member name="T:VRage.EnumComparer`1">
            <summary>
            A fast and efficient implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for Enum types.
            Useful for dictionaries that use Enums as their keys.
            </summary>
            <remarks>
            var dict = new Dictionary&lt;DayOfWeek, 
            string&gt;(EnumComparer&lt;DayOfWeek&gt;.Instance);
            </remarks>
            <typeparam name="TEnum">The type of the Enum.</typeparam>
        </member>
        <member name="F:VRage.EnumComparer`1.equalsFunct">
            <summary>
            
            </summary>
        </member>
        <member name="F:VRage.EnumComparer`1.getHashCodeFunct">
            <summary>
            
            </summary>
        </member>
        <member name="F:VRage.EnumComparer`1.instance">
            <summary>
            The singleton accessor.
            </summary>
        </member>
        <member name="M:VRage.EnumComparer`1.#cctor">
            <summary>
            Initializes the <see cref="T:VRage.EnumComparer`1"/> class
            by generating the GetHashCode and Equals methods.
            </summary>
        </member>
        <member name="M:VRage.EnumComparer`1.#ctor">
            <summary>
            A private constructor to prevent user instantiation.
            </summary>
        </member>
        <member name="M:VRage.EnumComparer`1.Equals(`0,`0)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            <param name="x">The first object of type <typeparamref name="TEnum"/> 
            to compare.</param>
            <param name="y">The second object of type <typeparamref name="TEnum"/> 
            to compare.</param>
            <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
        </member>
        <member name="M:VRage.EnumComparer`1.GetHashCode(`0)">
            <summary>
            Returns a hash code for the specified object.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> 
            for which a hash code is to be returned.</param>
            <returns>A hash code for the specified object.</returns>
            <exception cref="T:System.ArgumentNullException">
            The type of <paramref name="obj"/> is a reference type and 
            <paramref name="obj"/> is null.
            </exception>
        </member>
        <member name="M:VRage.EnumComparer`1.AssertTypeIsEnum">
            <summary>
            Asserts the type is enum.
            </summary>
        </member>
        <member name="M:VRage.EnumComparer`1.AssertUnderlyingTypeIsSupported">
            <summary>
            Asserts the underlying type is supported.
            </summary>
        </member>
        <member name="M:VRage.EnumComparer`1.GenerateEqualsFunct">
            <summary>
            Generates a comparison method similar to this:
            <code>
            bool Equals(TEnum x, TEnum y)
            {
                return x == y;
            }
            </code>
            </summary>
            <returns>The generated method.</returns>
        </member>
        <member name="M:VRage.EnumComparer`1.GenerateGetHashCodeFunct">
            <summary>
            Generates a GetHashCode method similar to this:
            <code>
            int GetHashCode(TEnum obj)
            {
                return ((int)obj).GetHashCode();
            }
            </code>
            </summary>
            <returns>The generated method.</returns>
        </member>
        <member name="P:VRage.EnumComparer`1.Instance">
            <summary>
            The singleton accessor.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:VRage.Collections.ObservableCollection`1" -->
        <member name="M:VRage.Collections.ObservableCollection`1.ClearItems">
            <summary>
            Clears the items.
            </summary>
        </member>
        <member name="M:VRage.Collections.ObservableCollection`1.GetEnumerator">
            <summary>
            Gets allocation free enumerator (returns struct)
            </summary>
        </member>
        <member name="T:VRage.Collections.ObservableCollection`1.Enumerator">
            <summary>
            Enumerator which uses index access.
            Index access on Collection is O(1) operation
            </summary>
        </member>
        <member name="M:VRage.Collections.LRUCache`2.AssertConsistent">
            <summary>
            Verifies that all assumptions are met (linked list is connected and all lookups are correct).
            FULLDEBUG is only here to disable this. Enable by changing to DEBUG if you suspect problems.
            </summary>
        </member>
        <member name="T:VRage.Exceptions">
            <summary>
            Provides a set of methods that help throwing exceptions. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:VRage.Exceptions.ThrowIf``1(System.Boolean)">
            <summary>
            Specifies a condition and throws an exception with the provided message if the condition is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="condition">The conditional expression to test.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowIf``1(System.Boolean,System.String)">
            <summary>
            Specifies a condition and throws an exception with the provided message if the condition is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="condition">The conditional expression to test.</param>
            <param name="arg1">The arg1.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowIf``1(System.Boolean,System.String,System.String)">
            <summary>
            Specifies a condition and throws an exception with the provided message if the condition is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="condition">The conditional expression to test.</param>
            <param name="arg1">The arg1.</param>
            <param name="arg2">The arg2.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowIf``1(System.Boolean,System.Object[])">
            <summary>
            Specifies a condition and throws an exception with the provided message if the condition is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="condition">The conditional expression to test.</param>
            <param name="args">Exception arguments.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowAny``1(System.Boolean[],System.Object[])">
            <summary>
            Specifies a conditions and throws an exception with the provided message if any of the conditions is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="conditions">The conditional expression to test.</param>
            <param name="args">Exception arguments.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowAll``1(System.Boolean[],System.Object[])">
            <summary>
            Specifies a conditions and throws an exception with the provided message if all conditions are true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="conditions">The conditional expression to test.</param>
            <param name="args">Exception arguments.</param>
        </member>
        <member name="M:VRage.MemberHelper`1.GetMember``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
             Gets the memberinfo of field/property on instance class.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="selector">The selector.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.MemberHelper.GetMember``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Gets the memberinfo of field/property on static class.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="selector">The selector.</param>
            <returns></returns>
        </member>
        <member name="T:VRage.MyFixedPoint">
            <summary>
            Fixed point number represented as 64-bit integer with 6 decimal places (one millionts)
            </summary>
        </member>
        <member name="M:VRage.MyFixedPoint.SerializeString">
            <summary>
            For XmlSerialization, format is 123.456789
            </summary>
        </member>
        <member name="M:VRage.MyFixedPoint.DeserializeStringSafe(System.String)">
            <summary>
            For XmlSerialization, format is 123.456789
            Handles double and decimal formats too.
            </summary>
        </member>
        <member name="T:System.PreloadRequiredAttribute">
            <summary>
            Specifies that this class requires preload before running the game
            Preload is be done when starting the app
            </summary>
        </member>
        <member name="T:VRage.Collections.MyConcurrentPool`1">
            <summary>
            Simple thread-safe pool.
            Can store external objects by calling return.
            Creates new instances when empty.
            </summary>
        </member>
        <member name="T:VRage.Collections.MyConcurrentQueue`1">
            <summary>
            Simple thread-safe queue.
            Uses spin-lock
            </summary>
        </member>
        <member name="M:VRage.IResourceLock.AcquireExclusive">
            <summary>
            Acquires the lock in exclusive mode, blocking if necessary.
            </summary>
        </member>
        <member name="M:VRage.IResourceLock.AcquireShared">
            <summary>
            Acquires the lock in shared mode, blocking if necessary.
            </summary>
        </member>
        <member name="M:VRage.IResourceLock.ReleaseExclusive">
            <summary>
            Releases the lock in exclusive mode.
            </summary>
        </member>
        <member name="M:VRage.IResourceLock.ReleaseShared">
            <summary>
            Releases the lock in shared mode.
            </summary>
        </member>
        <member name="M:VRage.IResourceLock.TryAcquireExclusive">
            <summary>
            Attempts to acquire the lock in exclusive mode.
            </summary>
            <returns>Whether the lock was acquired.</returns>
        </member>
        <member name="M:VRage.IResourceLock.TryAcquireShared">
            <summary>
            Attempts to acquire the lock in shared mode.
            </summary>
            <returns>Whether the lock was acquired.</returns>
        </member>
        <member name="M:VRage.FastResourceLockExtensions.AcquireSharedUsing(VRage.FastResourceLock)">
            <summary>
            Call dispose or use using block to release lock
            </summary>
        </member>
        <member name="M:VRage.FastResourceLockExtensions.AcquireExclusiveUsing(VRage.FastResourceLock)">
            <summary>
            Call dispose or use using block to release lock
            </summary>
        </member>
        <member name="T:VRage.Parallelization.MyPausableJob">
            <summary>
            Allows to pause one thread at exact points
            </summary>
        </member>
        <member name="T:ParallelTasks.IWork">
            <summary>
            An interface for a piece of work which can be executed by ParallelTasks.
            </summary>
        </member>
        <member name="M:ParallelTasks.IWork.DoWork">
            <summary>
            Executes the work.
            </summary>
        </member>
        <member name="P:ParallelTasks.IWork.Options">
            <summary>
            Gets options specifying how this work may be executed.
            </summary>
        </member>
        <member name="T:ParallelTasks.WorkPriority">
            <summary>
            These values are indices into array of queues which is searched starting at 0.
            </summary>
        </member>
        <member name="T:ParallelTasks.IWorkScheduler">
            <summary>
            An interface defining a task scheduler.
            </summary>
        </member>
        <member name="M:ParallelTasks.IWorkScheduler.Schedule(ParallelTasks.Task)">
            <summary>
            Schedules a task for execution.
            </summary>
            <param name="item">The task to schedule.</param>
        </member>
        <member name="M:ParallelTasks.IWorkScheduler.WaitForTasksToFinish(System.TimeSpan)">
            <summary>
            Wait for all tasks to finish the work.
            </summary>
        </member>
        <member name="P:ParallelTasks.IWorkScheduler.ThreadCount">
            <summary>
            Gets a number of threads.
            This number must be correct, because it's used to run per-thread initialization task on all threads (by using barrier)
            </summary>
        </member>
        <member name="T:ParallelTasks.Future`1">
            <summary>
            A task struct which can return a result.
            </summary>
            <typeparam name="T">The type of result this future calculates.</typeparam>
        </member>
        <member name="M:ParallelTasks.Future`1.GetResult">
            <summary>
            Gets the result. Blocks the calling thread until the future has completed execution.
            This can only be called once!
            </summary>
            <returns></returns>
        </member>
        <member name="P:ParallelTasks.Future`1.IsComplete">
            <summary>
            Gets a value which indicates if this future has completed.
            </summary>
        </member>
        <member name="P:ParallelTasks.Future`1.Exceptions">
            <summary>
            Gets an array containing any exceptions thrown by this future.
            </summary>
        </member>
        <member name="T:ParallelTasks.Hashtable`2">
            <summary>
            A thread safe hashtable.
            </summary>
            <typeparam name="Key">The type of item to use as keys.</typeparam>
            <typeparam name="Data">The type of data stored.</typeparam>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ParallelTasks.Hashtable`2"/> class.
            </summary>
            <param name="initialCapacity">The initial capacity of the table.</param>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.Add(`0,`1)">
            <summary>
            Adds an item to this hashtable.
            </summary>
            <param name="key">The key at which to add the item.</param>
            <param name="data">The data to add.</param>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.UnsafeSet(`0,`1)">
            <summary>
            Sets the value of the item at the specified key location.
            This is only guaranteed to work correctly if no other thread is modifying the same key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The new value.</param>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.TryGet(`0,`1@)">
            <summary>
            Tries to get the data at the specified key location.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="data">The data at the key location.</param>
            <returns><c>true</c> if the data was found; else <c>false</c>.</returns>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.Remove(`0)">
            <summary>
            Removes the data at the specified key location.
            </summary>
            <param name="key">The key.</param>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:ParallelTasks.Parallel">
            <summary>
            A static class containing factory methods for creating tasks.
            </summary>
        </member>
        <member name="M:ParallelTasks.Parallel.RunCallbacks">
            <summary>
            Executes all task callbacks on a single thread.
            This method is not re-entrant. It is suggested you call it only on the main thread.
            </summary>
        </member>
        <member name="M:ParallelTasks.Parallel.StartBackground(ParallelTasks.IWork)">
            <summary>
            Starts a task in a secondary worker thread. Intended for long running, blocking, work
            such as I/O.
            </summary>
            <param name="work">The work to execute.</param>
            <returns>A task which represents one execution of the work.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.StartBackground(ParallelTasks.IWork,System.Action)">
            <summary>
            Starts a task in a secondary worker thread. Intended for long running, blocking, work
            such as I/O.
            </summary>
            <param name="work">The work to execute.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A task which represents one execution of the work.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="work"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Invalid number of maximum threads set in <see cref="P:ParallelTasks.IWork.Options"/>.
            </exception>
        </member>
        <member name="M:ParallelTasks.Parallel.StartBackground(System.Action)">
            <summary>
            Starts a task in a secondary worker thread. Intended for long running, blocking, work
            such as I/O.
            </summary>
            <param name="action">The work to execute.</param>
            <returns>A task which represents one execution of the action.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.StartBackground(System.Action,System.Action)">
            <summary>
            Starts a task in a secondary worker thread. Intended for long running, blocking, work
            such as I/O.
            </summary>
            <param name="action">The work to execute.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A task which represents one execution of the action.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="action"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:ParallelTasks.Parallel.Start(ParallelTasks.IWork)">
            <summary>
            Creates and starts a task to execute the given work.
            </summary>
            <param name="work">The work to execute in parallel.</param>
            <returns>A task which represents one execution of the work.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start(ParallelTasks.IWork,System.Action)">
            <summary>
            Creates and starts a task to execute the given work.
            </summary>
            <param name="work">The work to execute in parallel.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A task which represents one execution of the work.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="work"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Invalid number of maximum threads set in <see cref="P:ParallelTasks.IWork.Options"/>.
            </exception>
        </member>
        <member name="M:ParallelTasks.Parallel.Start(System.Action)">
            <summary>
            Creates and starts a task to execute the given work.
            </summary>
            <param name="action">The work to execute in parallel.</param>
            <returns>A task which represents one execution of the work.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start(System.Action,System.Action)">
            <summary>
            Creates and starts a task to execute the given work.
            </summary>
            <param name="action">The work to execute in parallel.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A task which represents one execution of the work.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start(System.Action,ParallelTasks.WorkOptions)">
            <summary>
            Creates and starts a task to execute the given work.
            </summary>
            <param name="action">The work to execute in parallel.</param>
            <param name="options">The work options to use with this action.</param>
            <returns>A task which represents one execution of the work.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start(System.Action,ParallelTasks.WorkOptions,System.Action)">
            <summary>
            Creates and starts a task to execute the given work.
            </summary>
            <param name="action">The work to execute in parallel.</param>
            <param name="options">The work options to use with this action.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A task which represents one execution of the work.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.StartOnEachWorker(System.Action,System.Boolean)">
            <summary>
            Starts same task on each worker, each worker executes this task exactly once.
            Good for initialization and release of per-thread resources.
            THIS CANNOT BE RUN FROM ANY WORKER!
            </summary>
        </member>
        <member name="M:ParallelTasks.Parallel.Start``1(System.Func{``0})">
            <summary>
            Creates and starts a task which executes the given function and stores the result for later retrieval.
            </summary>
            <typeparam name="T">The type of result the function returns.</typeparam>
            <param name="function">The function to execute in parallel.</param>
            <returns>A future which represults one execution of the function.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start``1(System.Func{``0},System.Action)">
            <summary>
            Creates and starts a task which executes the given function and stores the result for later retrieval.
            </summary>
            <typeparam name="T">The type of result the function returns.</typeparam>
            <param name="function">The function to execute in parallel.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A future which represults one execution of the function.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start``1(System.Func{``0},ParallelTasks.WorkOptions)">
            <summary>
            Creates and starts a task which executes the given function and stores the result for later retrieval.
            </summary>
            <typeparam name="T">The type of result the function returns.</typeparam>
            <param name="function">The function to execute in parallel.</param>
            <param name="options">The work options to use with this action.</param>
            <returns>A future which represents one execution of the function.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start``1(System.Func{``0},ParallelTasks.WorkOptions,System.Action)">
            <summary>
            Creates and starts a task which executes the given function and stores the result for later retrieval.
            </summary>
            <typeparam name="T">The type of result the function returns.</typeparam>
            <param name="function">The function to execute in parallel.</param>
            <param name="options">The work options to use with this action.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A future which represents one execution of the function.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Do(ParallelTasks.IWork,ParallelTasks.IWork)">
            <summary>
            Executes the given work items potentially in parallel with each other.
            This method will block until all work is completed.
            </summary>
            <param name="a">Work to execute.</param>
            <param name="b">Work to execute.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.Do(ParallelTasks.IWork[])">
            <summary>
            Executes the given work items potentially in parallel with each other.
            This method will block until all work is completed.
            </summary>
            <param name="work">The work to execute.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.Do(System.Action,System.Action)">
            <summary>
            Executes the given work items potentially in parallel with each other.
            This method will block until all work is completed.
            </summary>
            <param name="action1">The work to execute.</param>
            <param name="action2">The work to execute.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.Do(System.Action[])">
            <summary>
            Executes the given work items potentially in parallel with each other.
            This method will block until all work is completed.
            </summary>
            <param name="actions">The work to execute.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})">
            <summary>
            Executes a for loop, where each iteration can potentially occur in parallel with others.
            </summary>
            <param name="startInclusive">The index (inclusive) at which to start iterating.</param>
            <param name="endExclusive">The index (exclusive) at which to end iterating.</param>
            <param name="body">The method to execute at each iteration. The current index is supplied as the parameter.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32},System.Int32)">
            <summary>
            Executes a for loop, where each iteration can potentially occur in parallel with others.
            </summary>
            <param name="startInclusive">The index (inclusive) at which to start iterating.</param>
            <param name="endExclusive">The index (exclusive) at which to end iterating.</param>
            <param name="body">The method to execute at each iteration. The current index is supplied as the parameter.</param>
            <param name="stride">The number of iterations that each processor takes at a time.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Executes a foreach loop, where each iteration can potentially occur in parallel with others.
            </summary>
            <typeparam name="T">The type of item to iterate over.</typeparam>
            <param name="collection">The enumerable data source.</param>
            <param name="action">The method to execute at each iteration. The item to process is supplied as the parameter.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.WaitForAll(System.Threading.WaitHandle[],System.TimeSpan)">
            <summary>
            Safe version of WaitHandle.WaitForMultiple, but create new MTA thread when called from STA thread
            </summary>
            <param name="waitHandles"></param>
        </member>
        <member name="P:ParallelTasks.Parallel.ProcessorAffinity">
            <summary>
            Gets or sets the processor affinity of the worker threads.
            </summary>
            <value>
            The processor affinity of the worker threads. The default value is <c>{ 3, 4, 5, 1 }</c>.
            </value>
            <remarks>
            <para>
            In the .NET Compact Framework for Xbox 360 the processor affinity determines the processors 
            on which a thread runs. 
            </para>
            <para>
            <strong>Note:</strong> The processor affinity is only relevant in the .NET Compact Framework 
            for Xbox 360. Setting the processor affinity has no effect in Windows!
            </para>
            <para>
            <strong>Important:</strong> The processor affinity needs to be set before any parallel tasks
            are created. Changing the processor affinity afterwards has no effect.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            The specified array is empty or contains invalid values.
            </exception>
        </member>
        <member name="P:ParallelTasks.Parallel.Scheduler">
            <summary>
            Gets or sets the work scheduler.
            </summary>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="T:ParallelTasks.Pool`1">
            <summary>
            A thread safe, non-blocking, object pool.
            </summary>
            <typeparam name="T">The type of item to store. Must be a class with a parameterless constructor.</typeparam>
        </member>
        <member name="T:ParallelTasks.Singleton`1">
            <summary>
            Implements a singleton instance of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of object to create a singleton instance of.</typeparam>
        </member>
        <member name="P:ParallelTasks.Singleton`1.Instance">
            <summary>
            Gets a singleton instance.
            </summary>
            <value>The instance.</value>
        </member>
        <member name="M:ParallelTasks.Pool`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ParallelTasks.Pool`1"/> class.
            </summary>
        </member>
        <member name="M:ParallelTasks.Pool`1.Get(System.Threading.Thread)">
            <summary>
            Gets an instance from the pool.
            </summary>
            <returns>An instance of <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:ParallelTasks.Pool`1.Return(System.Threading.Thread,`0)">
            <summary>
            Returns an instance to the pool, so it is available for re-use.
            It is advised that the item is reset to a default state before being returned.
            </summary>
            <param name="instance">The instance to return to the pool.</param>
        </member>
        <member name="T:ParallelTasks.Semaphore">
            <summary>
            A semaphore class.
            </summary>
        </member>
        <member name="M:ParallelTasks.Semaphore.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:ParallelTasks.Semaphore"/> class.
            </summary>
            <param name="maximumCount"></param>
        </member>
        <member name="M:ParallelTasks.Semaphore.WaitOne">
            <summary>
            Blocks the calling thread until resources are made available, then consumes one resource.
            </summary>
        </member>
        <member name="M:ParallelTasks.Semaphore.Release">
            <summary>
            Adds one resource.
            </summary>
        </member>
        <member name="T:ParallelTasks.SpinLock">
            <summary>
            A struct which implements a spin lock.
            </summary>
        </member>
        <member name="M:ParallelTasks.SpinLock.Enter">
            <summary>
            Enters the lock. The calling thread will spin wait until it gains ownership of the lock.
            </summary>
        </member>
        <member name="M:ParallelTasks.SpinLock.TryEnter">
            <summary>
            Tries to enter the lock.
            </summary>
            <returns><c>true</c> if the lock was successfully taken; else <c>false</c>.</returns>
        </member>
        <member name="M:ParallelTasks.SpinLock.Exit">
            <summary>
            Exits the lock. This allows other threads to take ownership of the lock.
            </summary>
        </member>
        <member name="T:ParallelTasks.Task">
            <summary>
            A struct which represents a single execution of an IWork instance.
            </summary>
        </member>
        <member name="M:ParallelTasks.Task.Wait">
            <summary>
            Waits for the task to complete.
            </summary>
        </member>
        <member name="P:ParallelTasks.Task.IsComplete">
            <summary>
            Gets a value which indicates if this task has completed.
            </summary>
        </member>
        <member name="P:ParallelTasks.Task.Exceptions">
            <summary>
            Gets an array containing any exceptions thrown by this task.
            </summary>
        </member>
        <member name="T:ParallelTasks.TaskException">
            <summary>
            An exception thrown when an unhandled exception is thrown within a task.
            </summary>
        </member>
        <member name="M:ParallelTasks.TaskException.#ctor(System.Exception[])">
            <summary>
            Creates a new instance of the <see cref="T:ParallelTasks.TaskException"/> class.
            </summary>
            <param name="inner">The unhandled exceptions thrown by the task.</param>
        </member>
        <member name="P:ParallelTasks.TaskException.InnerExceptions">
            <summary>
            Gets an array containing any unhandled exceptions that were thrown by the task.
            </summary>
        </member>
        <member name="T:ParallelTasks.WorkOptions">
            <summary>
            A struct containing options about how an IWork instance can be executed.
            </summary>
        </member>
        <member name="P:ParallelTasks.WorkOptions.DetachFromParent">
            <summary>
            Gets or sets a value indicating if the work will be created detached from its parent.
            If <c>false</c>, the parent task will wait for this work to complete before itself completing.
            </summary>
        </member>
        <member name="P:ParallelTasks.WorkOptions.MaximumThreads">
            <summary>
            Gets or sets the maximum number of threads which can concurrently execute this work.
            </summary>
        </member>
        <member name="P:ParallelTasks.WorkOptions.QueueFIFO">
            <summary>
            Gets or sets a value indicating that this work should be queued in a first in first out fashion.
            </summary>
        </member>
        <member name="T:ParallelTasks.WorkStealingScheduler">
            <summary>
            A "work stealing" work scheduler class.
            </summary>
        </member>
        <member name="M:ParallelTasks.WorkStealingScheduler.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:ParallelTasks.WorkStealingScheduler"/> class.
            </summary>
        </member>
        <member name="M:ParallelTasks.WorkStealingScheduler.#ctor(System.Int32,System.Threading.ThreadPriority)">
            <summary>
            Creates a new instance of the <see cref="T:ParallelTasks.WorkStealingScheduler"/> class.
            </summary>
            <param name="numThreads">The number of threads to create.</param>
        </member>
        <member name="M:ParallelTasks.WorkStealingScheduler.Schedule(ParallelTasks.Task)">
            <summary>
            Schedules a task for execution.
            </summary>
            <param name="task">The task to schedule.</param>
        </member>
        <member name="T:VRage.Profiler.MyProfiler">
            <summary>
            Part of MyRenderProfiler, this is per-thread profiler
            </summary>
        </member>
        <member name="F:VRage.Profiler.MyProfiler.AutoCommit">
            <summary>
            Enable for background workers.
            It will automatically commit after top level profiling block is closed
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyProfiler.OnHistorySafe">
            <summary>
            End operation on history data
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyProfiler.CommitFrame">
            <summary>
            Adds current frame to history and clear it
            Returns number of calls this frame
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyProfiler.ClearFrame">
            <summary>
            Clears current frame.
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyProfiler.MyProfilerBlock.Clear">
            <summary>
            Clears immediate data
            </summary>
        </member>
        <member name="T:ProtoBuf.BclHelpers">
            <summary>
            Provides support for common .NET types that do not have a direct representation
            in protobuf, using the definitions from bcl.proto
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.GetUninitializedObject(System.Type)">
            <summary>
            Creates a new instance of the specified type, bypassing the constructor.
            </summary>
            <param name="type">The type to create</param>
            <returns>The new instance</returns>
            <exception cref="T:System.NotSupportedException">If the platform does not support constructor-skipping</exception>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteTimeSpan(System.TimeSpan,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a TimeSpan to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadTimeSpan(ProtoBuf.ProtoReader)">
            <summary>
            Parses a TimeSpan from a protobuf stream
            </summary>        
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDateTime(ProtoBuf.ProtoReader)">
            <summary>
            Parses a DateTime from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDateTime(System.DateTime,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a DateTime to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadDecimal(ProtoBuf.ProtoReader)">
            <summary>
            Parses a decimal from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteDecimal(System.Decimal,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a decimal to a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteGuid(System.Guid,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a Guid to a protobuf stream
            </summary>        
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadGuid(ProtoBuf.ProtoReader)">
            <summary>
            Parses a Guid from a protobuf stream
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.ReadNetObject(System.Object,ProtoBuf.ProtoReader,System.Int32,System.Type,ProtoBuf.BclHelpers.NetObjectOptions)">
            <summary>
            Reads an *implementation specific* bundled .NET object, including (as options) type-metadata, identity/re-use, etc.
            </summary>
        </member>
        <member name="M:ProtoBuf.BclHelpers.WriteNetObject(System.Object,ProtoBuf.ProtoWriter,System.Int32,ProtoBuf.BclHelpers.NetObjectOptions)">
            <summary>
            Writes an *implementation specific* bundled .NET object, including (as options) type-metadata, identity/re-use, etc.
            </summary>
        </member>
        <member name="T:ProtoBuf.BclHelpers.NetObjectOptions">
            <summary>
            Optional behaviours that introduce .NET-specific functionality
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.None">
            <summary>
            No special behaviour
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.UseConstructor">
            <summary>
            If false, the constructor for the type is bypassed during deserialization, meaning any field initializers
            or other initialization code is skipped.
            </summary>
        </member>
        <member name="F:ProtoBuf.BclHelpers.NetObjectOptions.LateSet">
            <summary>
            Should the object index be reserved, rather than creating an object promptly
            </summary>
        </member>
        <member name="T:ProtoBuf.BufferExtension">
            <summary>
            Provides a simple buffer-based implementation of an <see cref="T:ProtoBuf.IExtension">extension</see> object.
            </summary>
        </member>
        <member name="T:ProtoBuf.IExtension">
            <summary>
            Provides addition capability for supporting unexpected fields during
            protocol-buffer serialization/deserialization. This allows for loss-less
            round-trip/merge, even when the data is not fully understood.
            </summary>
        </member>
        <member name="M:ProtoBuf.IExtension.BeginAppend">
            <summary>
            Requests a stream into which any unexpected fields can be persisted.
            </summary>
            <returns>A new stream suitable for storing data.</returns>
        </member>
        <member name="M:ProtoBuf.IExtension.EndAppend(System.IO.Stream,System.Boolean)">
            <summary>
            Indicates that all unexpected fields have now been stored. The
            implementing class is responsible for closing the stream. If
            "commit" is not true the data may be discarded.
            </summary>
            <param name="stream">The stream originally obtained by BeginAppend.</param>
            <param name="commit">True if the append operation completed successfully.</param>
        </member>
        <member name="M:ProtoBuf.IExtension.BeginQuery">
            <summary>
            Requests a stream of the unexpected fields previously stored.
            </summary>
            <returns>A prepared stream of the unexpected fields.</returns>
        </member>
        <member name="M:ProtoBuf.IExtension.EndQuery(System.IO.Stream)">
            <summary>
            Indicates that all unexpected fields have now been read. The
            implementing class is responsible for closing the stream.
            </summary>
            <param name="stream">The stream originally obtained by BeginQuery.</param>
        </member>
        <member name="M:ProtoBuf.IExtension.GetLength">
            <summary>
            Requests the length of the raw binary stream; this is used
            when serializing sub-entities to indicate the expected size.
            </summary>
            <returns>The length of the binary stream representing unexpected data.</returns>
        </member>
        <member name="T:ProtoBuf.ProtoBeforeSerializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked before serialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoAfterSerializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked after serialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoBeforeDeserializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked before deserialization.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoAfterDeserializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked after deserialization.</summary>
        </member>
        <member name="M:ProtoBuf.Compiler.CompilerContext.LoadNullRef">
            <summary>
            Pushes a null reference onto the stack. Note that this should only
            be used to return a null (or set a variable to null); for null-tests
            use BranchIfTrue / BranchIfFalse.
            </summary>
        </member>
        <member name="M:ProtoBuf.Compiler.CompilerContext.UsingBlock.#ctor(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
            <summary>
            Creates a new "using" block (equivalent) around a variable;
            the variable must exist, and note that (unlike in C#) it is
            the variables *final* value that gets disposed. If you need
            *original* disposal, copy your variable first.
            
            It is the callers responsibility to ensure that the variable's
            scope fully-encapsulates the "using"; if not, the variable
            may be re-used (and thus re-assigned) unexpectedly.
            </summary>
        </member>
        <member name="T:ProtoBuf.DataFormat">
            <summary>
            Sub-format to use when serializing/deserializing data
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.Default">
            <summary>
            Uses the default encoding for the data-type.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.ZigZag">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that zigzag variant encoding will be used. This means that values
            with small magnitude (regardless of sign) take a small amount
            of space to encode.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.TwosComplement">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that two's-complement variant encoding will be used.
            This means that any -ve number will take 10 bytes (even for 32-bit),
            so should only be used for compatibility.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.FixedSize">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that a fixed amount of space will be used.
            </summary>
        </member>
        <member name="F:ProtoBuf.DataFormat.Group">
            <summary>
            When applied to a sub-message, indicates that the value should be treated
            as group-delimited.
            </summary>
        </member>
        <member name="T:ProtoBuf.Extensible">
            <summary>
            Simple base class for supporting unexpected fields allowing
            for loss-less round-tips/merge, even if the data is not understod.
            The additional fields are (by default) stored in-memory in a buffer.
            </summary>
            <remarks>As an example of an alternative implementation, you might
            choose to use the file system (temporary files) as the back-end, tracking
            only the paths [such an object would ideally be IDisposable and use
            a finalizer to ensure that the files are removed].</remarks>
            <seealso cref="T:ProtoBuf.IExtensible"/>
        </member>
        <member name="T:ProtoBuf.IExtensible">
            <summary>
            Indicates that the implementing type has support for protocol-buffer
            <see cref="T:ProtoBuf.IExtension">extensions</see>.
            </summary>
            <remarks>Can be implemented by deriving from Extensible.</remarks>
        </member>
        <member name="M:ProtoBuf.IExtensible.GetExtensionObject(System.Boolean)">
            <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:ProtoBuf.Extensible.GetExtensionObject(System.Boolean)">
            <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:ProtoBuf.Extensible.GetExtensionObject(ProtoBuf.IExtension@,System.Boolean)">
            <summary>
            Provides a simple, default implementation for <see cref="T:ProtoBuf.IExtension">extension</see> support,
            optionally creating it if it does not already exist. Designed to be called by
            classes implementing <see cref="T:ProtoBuf.IExtensible"/>.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <param name="extensionObject">The extension field to check (and possibly update).</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,``0)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The type of the value to append.</typeparam>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="format">The data-format to use when encoding the value.</param>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>The effective value of the field, or the default value if not found.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>The effective value of the field, or the default value if not found.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.TryGetValue(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Object@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <param name="type">The data-type of the field.</param>
            <param name="model">The model to use for configuration.</param>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.GetValues(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <param name="model">The model to use for configuration.</param>
            <param name="type">The data-type of the field.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:ProtoBuf.Extensible.AppendValue(ProtoBuf.Meta.TypeModel,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Object)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <param name="model">The model to use for configuration.</param>
            <param name="format">The data-format to use when encoding the value.</param>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="T:ProtoBuf.ExtensibleUtil">
            <summary>
            This class acts as an internal wrapper allowing us to do a dynamic
            methodinfo invoke; an't put into Serializer as don't want on public
            API; can't put into Serializer&lt;T&gt; since we need to invoke
            accross classes, which isn't allowed in Silverlight)
            </summary>
        </member>
        <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValues``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
            <summary>
            All this does is call GetExtendedValuesTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
        </member>
        <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValues(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
            <summary>
            All this does is call GetExtendedValuesTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
        </member>
        <member name="M:ProtoBuf.ExtensibleUtil.AppendExtendValueTyped``2(ProtoBuf.Meta.TypeModel,``0,System.Int32,ProtoBuf.DataFormat,``1)">
            <summary>
            Stores the given value into the instance's stream; the serializer
            is inferred from TValue and format.
            </summary>
            <remarks>Needs to be public to be callable thru reflection in Silverlight</remarks>
        </member>
        <member name="T:ProtoBuf.Helpers">
            <summary>
            Not all frameworks are created equal (fx1.1 vs fx2.0,
            micro-framework, compact-framework,
            silverlight, etc). This class simply wraps up a few things that would
            otherwise make the real code unnecessarily messy, providing fallback
            implementations if necessary.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoTypeCode">
            <summary>
            Intended to be a direct map to regular TypeCode, but:
            - with missing types
            - existing on WinRT
            </summary>
        </member>
        <member name="T:ProtoBuf.ImplicitFields">
            <summary>
            Specifies the method used to infer field tags for members of the type
            under consideration. Tags are deduced using the invariant alphabetic
            sequence of the members' names; this makes implicit field tags very brittle,
            and susceptible to changes such as field names (normally an isolated
            change).
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.None">
            <summary>
            No members are serialized implicitly; all members require a suitable
            attribute such as [ProtoMember]. This is the recmomended mode for
            most scenarios.
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.AllPublic">
            <summary>
            Public properties and fields are eligible for implicit serialization;
            this treats the public API as a contract. Ordering beings from ImplicitFirstTag.
            </summary>
        </member>
        <member name="F:ProtoBuf.ImplicitFields.AllFields">
            <summary>
            Public and non-public fields are eligible for implicit serialization;
            this acts as a state/implementation serializer. Ordering beings from ImplicitFirstTag.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.CallbackSet">
            <summary>
            Represents the set of serialization callbacks to be used when serializing/deserializing a type.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.BeforeSerialize">
            <summary>Called before serializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.BeforeDeserialize">
            <summary>Called before deserializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.AfterSerialize">
            <summary>Called after serializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.AfterDeserialize">
            <summary>Called after deserializing an instance</summary>
        </member>
        <member name="P:ProtoBuf.Meta.CallbackSet.NonTrivial">
            <summary>
            True if any callback is set, else False
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.MetaType">
            <summary>
            Represents a type at runtime for use with protobuf, allowing the field mappings (etc) to be defined
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.ToString">
            <summary>
            Get the name of the type being represented
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddSubType(System.Int32,System.Type)">
            <summary>
            Adds a known sub-type to the inheritance model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddSubType(System.Int32,System.Type,ProtoBuf.DataFormat)">
            <summary>
            Adds a known sub-type to the inheritance model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetCallbacks(System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Assigns the callbacks to use during serialiation/deserialization.
            </summary>
            <param name="beforeSerialize">The method (or null) called before serialization begins.</param>
            <param name="afterSerialize">The method (or null) called when serialization is complete.</param>
            <param name="beforeDeserialize">The method (or null) called before deserialization begins (or when a new instance is created during deserialization).</param>
            <param name="afterDeserialize">The method (or null) called when deserialization is complete.</param>
            <returns>The set of callbacks.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetCallbacks(System.String,System.String,System.String,System.String)">
            <summary>
            Assigns the callbacks to use during serialiation/deserialization.
            </summary>
            <param name="beforeSerialize">The name of the method (or null) called before serialization begins.</param>
            <param name="afterSerialize">The name of the method (or null) called when serialization is complete.</param>
            <param name="beforeDeserialize">The name of the method (or null) called before deserialization begins (or when a new instance is created during deserialization).</param>
            <param name="afterDeserialize">The name of the method (or null) called when deserialization is complete.</param>
            <returns>The set of callbacks.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetFactory(System.Reflection.MethodInfo)">
            <summary>
            Designate a factory-method to use to create instances of this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetFactory(System.String)">
            <summary>
            Designate a factory-method to use to create instances of this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.ThrowIfFrozen">
            <summary>
            Throws an exception if the type has been made immutable
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>        
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddField(System.Int32,System.String)">
            <summary>
            Adds a member (by name) to the MetaType, returning the ValueMember rather than the fluent API.
            This is otherwise identical to Add.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.String)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>     
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.SetSurrogate(System.Type)">
            <summary>
            Performs serialization of this type via a surrogate; all
            other serialization options are ignored and handled
            by the surrogate's configuration.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.String[])">
            <summary>
            Adds a set of members (by name) to the MetaType
            </summary>     
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String,System.Object)">
            <summary>
            Adds a member (by name) to the MetaType
            </summary>        
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String,System.Type,System.Type)">
            <summary>
            Adds a member (by name) to the MetaType, including an itemType and defaultType for representing lists
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.AddField(System.Int32,System.String,System.Type,System.Type)">
            <summary>
            Adds a member (by name) to the MetaType, including an itemType and defaultType for representing lists, returning the ValueMember rather than the fluent API.
            This is otherwise identical to Add.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.GetFields">
            <summary>
            Returns the ValueMember instances associated with this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.GetSubtypes">
            <summary>
            Returns the SubType instances associated with this type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.MetaType.CompileInPlace">
            <summary>
            Compiles the serializer for this type; this is *not* a full
            standalone compile, but can significantly boost performance
            while allowing additional types to be added.
            </summary>
            <remarks>An in-place compile can access non-public types / members</remarks>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.BaseType">
            <summary>
            Gets the base-type for this type
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.IncludeSerializerMethod">
            <summary>
            When used to compile a model, should public serialization/deserialzation methods
            be included for this type?
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.AsReferenceDefault">
            <summary>
            Should this type be treated as a reference by default?
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.HasCallbacks">
            <summary>
            Indicates whether the current type has defined callbacks 
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.HasSubtypes">
            <summary>
            Indicates whether the current type has defined subtypes
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Callbacks">
            <summary>
            Returns the set of callbacks defined for this type
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Name">
            <summary>
            Gets or sets the name of this contract.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Type">
            <summary>
            The runtime type that the meta-type represents
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.UseConstructor">
            <summary>
            Gets or sets whether the type should use a parameterless constructor (the default),
            or whether the type should skip the constructor completely. This option is not supported
            on compact-framework.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.ConstructType">
            <summary>
            The concrete type to create when a new instance of this type is needed; this may be useful when dealing
            with dynamic proxies, or with interface-based APIs
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Item(System.Int32)">
            <summary>
            Returns the ValueMember that matchs a given field number, or null if not found
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.Item(System.Reflection.MemberInfo)">
            <summary>
            Returns the ValueMember that matchs a given member (property/field), or null if not found
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.EnumPassthru">
            <summary>
            Gets or sets a value indicating that an enum should be treated directly as an int/short/etc, rather
            than enforcing .proto enum rules. This is useful *in particul* for [Flags] enums.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.MetaType.IgnoreListHandling">
            <summary>
            Gets or sets a value indicating that this type should NOT be treated as a list, even if it has
            familiar list-like characteristics (enumerable, add, etc)
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.RuntimeTypeModel">
            <summary>
            Provides protobuf serialization support for a number of types that can be defined at runtime
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeModel">
            <summary>
            Provides protobuf serialization support for a number of types
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.MapType(System.Type)">
            <summary>
            Resolve a System.Type to the compiler-specific type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.MapType(System.Type,System.Boolean)">
            <summary>
            Resolve a System.Type to the compiler-specific type
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.TrySerializeAuxiliaryType(ProtoBuf.ProtoWriter,System.Type,ProtoBuf.DataFormat,System.Int32,System.Object,System.Boolean)">
            <summary>
            This is the more "complete" version of Serialize, which handles single instances of mapped types.
            The value is written as a complete field, including field-header and (for sub-objects) a
            length-prefix
            In addition to that, this provides support for:
             - basic values; individual int / string / Guid / etc
             - IEnumerable sequences of any type handled by TrySerializeAuxiliaryType
             
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.IO.Stream,System.Object,ProtoBuf.SerializationContext)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(ProtoBuf.ProtoWriter,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied writer.
            </summary>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination writer to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver,System.Int32@)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="type">The type being merged.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <param name="bytesRead">Returns the number of bytes consumed by this operation (includes length-prefix overheads and any skipped data).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems(System.IO.Stream,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <param name="resolver">On a field-by-field basis, the type of object to deserialize (can be null if "type" is specified). </param>
            <param name="type">The type of object to deserialize (can be null if "resolver" is specified).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems(System.IO.Stream,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver,ProtoBuf.SerializationContext)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <param name="resolver">On a field-by-field basis, the type of object to deserialize (can be null if "type" is specified). </param>
            <param name="type">The type of object to deserialize (can be null if "resolver" is specified).</param>
            <returns>The sequence of deserialized objects.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.SerializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="type">The type being serialized.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.SerializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="type">The type being serialized.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="dest">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,ProtoBuf.SerializationContext)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int32)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int32,ProtoBuf.SerializationContext)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="length">The number of bytes to consume (or -1 to read to the end of the stream).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(ProtoBuf.ProtoReader,System.Object,System.Type)">
            <summary>
            Applies a protocol-buffer reader to an existing instance (which may be null).
            </summary>
            <param name="type">The type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The reader to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.TryDeserializeAuxiliaryType(ProtoBuf.ProtoReader,ProtoBuf.DataFormat,System.Int32,System.Type,System.Object@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            This is the more "complete" version of Deserialize, which handles single instances of mapped types.
            The value is read as a complete field, including field-header and (for sub-objects) a
            length-prefix..kmc  
            
            In addition to that, this provides support for:
             - basic values; individual int / string / Guid / etc
             - IList sets of any type handled by TryDeserializeAuxiliaryType
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Create">
            <summary>
            Creates a new runtime model, to which the caller
            can add support for a range of types. A model
            can be used "as is", or can be compiled for
            optimal performance.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ResolveProxies(System.Type)">
            <summary>
            Applies common proxy scenarios, resolving the actual type to consider
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.IsDefined(System.Type)">
            <summary>
            Indicates whether the supplied type is explicitly modelled by the model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetKey(System.Type@)">
            <summary>
            Provides the key that represents a given type in the current model.
            The type is also normalized for proxies at the same time.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetKeyImpl(System.Type)">
            <summary>
            Provides the key that represents a given type in the current model.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.Int32,System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.Int32,System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.DeepClone(System.Object)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedSubtype(System.Type,System.Type)">
            <summary>
            Indicates that while an inheritance tree exists, the exact type encountered was not
            specified in that hierarchy and cannot be processed.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedType(System.Type)">
            <summary>
            Indicates that the given type was not expected, and cannot be processed.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.ThrowCannotCreateInstance(System.Type)">
            <summary>
            Indicates that the given type cannot be constructed; it may still be possible to 
            deserialize into existing instances.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CanSerializeContractType(System.Type)">
            <summary>
            Returns true if the type supplied is either a recognised contract type,
            or a *list* of a recognised contract type. 
            </summary>
            <remarks>Note that primitives always return false, even though the engine
            will, if forced, try to serialize such</remarks>
            <returns>True if this type is recognised as a serializable entity, else false</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CanSerialize(System.Type)">
            <summary>
            Returns true if the type supplied is a basic type with inbuilt handling,
            a recognised contract type, or a *list* of a basic / contract type. 
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CanSerializeBasicType(System.Type)">
            <summary>
            Returns true if the type supplied is a basic type with inbuilt handling,
            or a *list* of a basic type with inbuilt handling
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.GetSchema(System.Type)">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <param name="type">The type to generate a .proto definition for, or <c>null</c> to generate a .proto that represents the entire model</param>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="M:ProtoBuf.Meta.TypeModel.CreateFormatter(System.Type)">
            <summary>
            Creates a new IFormatter that uses protocol-buffer [de]serialization.
            </summary>
            <returns>A new IFormatter to be used during [de]serialization.</returns>
            <param name="type">The type of object to be [de]deserialized by the formatter.</param>
        </member>
        <member name="E:ProtoBuf.Meta.TypeModel.DynamicTypeFormatting">
            <summary>
            Used to provide custom services for writing and parsing type names when using dynamic types. Both parsing and formatting
            are provided on a single API as it is essential that both are mapped identically at all times.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeModel.CallbackType">
            <summary>
            Indicates the type of callback to be used
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.BeforeSerialize">
            <summary>
            Invoked before an object is serialized
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.AfterSerialize">
            <summary>
            Invoked after an object is serialized
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.BeforeDeserialize">
            <summary>
            Invoked before an object is deserialized (or when a new instance is created)
            </summary>            
        </member>
        <member name="F:ProtoBuf.Meta.TypeModel.CallbackType.AfterDeserialize">
            <summary>
            Invoked after an object is deserialized
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetTypes">
            <summary>
            Returns a sequence of the Type instances that can be
            processed by this model.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetSchema(System.Type)">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <param name="type">The type to generate a .proto definition for, or <c>null</c> to generate a .proto that represents the entire model</param>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Add(System.Type,System.Boolean)">
            <summary>
            Adds support for an additional type in this model, optionally
            appplying inbuilt patterns. If the type is already known to the
            model, the existing type is returned **without** applying
            any additional behaviour.
            </summary>
            <remarks>Inbuilt patterns include:
            [ProtoContract]/[ProtoMember(n)]
            [DataContract]/[DataMember(Order=n)]
            [XmlType]/[XmlElement(Order=n)]
            [On{Des|S}erializ{ing|ed}]
            ShouldSerialize*/*Specified
            </remarks>
            <param name="type">The type to be supported</param>
            <param name="applyDefaultBehaviour">Whether to apply the inbuilt configuration patterns (via attributes etc), or
            just add the type with no additional configuration (the type must then be manually configured).</param>
            <returns>The MetaType representing this type, allowing
            further configuration.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.ThrowIfFrozen">
            <summary>
            Verifies that the model is still open to changes; if not, an exception is thrown
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Freeze">
            <summary>
            Prevents further changes to this model
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetKeyImpl(System.Type)">
            <summary>
            Provides the key that represents a given type in the current model.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Serialize(System.Int32,System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Deserialize(System.Int32,System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
            <param name="key">Represents the type (including inheritance) to consider.</param>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.CompileInPlace">
            <summary>
            Compiles the serializers individually; this is *not* a full
            standalone compile, but can significantly boost performance
            while allowing additional types to be added.
            </summary>
            <remarks>An in-place compile can access non-public types / members</remarks>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Compile">
            <summary>
            Fully compiles the current model into a static-compiled model instance
            </summary>
            <remarks>A full compilation is restricted to accessing public types / members</remarks>
            <returns>An instance of the newly created compiled type-model</returns>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Compile(System.String,System.String)">
            <summary>
            Fully compiles the current model into a static-compiled serialization dll
            (the serialization dll still requires protobuf-net for support services).
            </summary>
            <remarks>A full compilation is restricted to accessing public types / members</remarks>
            <param name="name">The name of the TypeModel class to create</param>
            <param name="path">The path for the new dll</param>
            <returns>An instance of the newly created compiled type-model</returns>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Compile(ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions)">
            <summary>
            Fully compiles the current model into a static-compiled serialization dll
            (the serialization dll still requires protobuf-net for support services).
            </summary>
            <remarks>A full compilation is restricted to accessing public types / members</remarks>
            <returns>An instance of the newly created compiled type-model</returns>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.SetDefaultFactory(System.Reflection.MethodInfo)">
            <summary>
            Designate a factory-method to use to create instances of any type; note that this only affect types seen by the serializer *after* setting the factory.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.InferTagFromNameDefault">
            <summary>
            Global default that
            enables/disables automatic tag generation based on the existing name / order
            of the defined members. See <seealso cref="P:ProtoBuf.ProtoContractAttribute.InferTagFromName"/>
            for usage and <b>important warning</b> / explanation.
            You must set the global default before attempting to serialize/deserialize any
            impacted type.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoAddProtoContractTypesOnly">
            <summary>
            Global default that determines whether types are considered serializable
            if they have [DataContract] / [XmlType]. With this enabled, <b>ONLY</b>
            types marked as [ProtoContract] are added automatically.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.UseImplicitZeroDefaults">
            <summary>
            Global switch that enables or disables the implicit
            handling of "zero defaults"; meanning: if no other default is specified,
            it assumes bools always default to false, integers to zero, etc.
            
            If this is disabled, no such assumptions are made and only *explicit*
            default values are processed. This is enabled by default to 
            preserve similar logic to v1.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AllowParseableTypes">
            <summary>
            Global switch that determines whether types with a <c>.ToString()</c> and a <c>Parse(string)</c>
            should be serialized as strings.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.Default">
            <summary>
            The default model, used to support ProtoBuf.Serializer
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.Item(System.Type)">
            <summary>
            Obtains the MetaType associated with a given Type for the current model,
            allowing additional configuration.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoCompile">
            <summary>
            Should serializers be compiled on demand? It may be useful
            to disable this for debugging purposes.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoAddMissingTypes">
            <summary>
            Should support for unexpected types be added automatically?
            If false, an exception is thrown when unexpected types
            are encountered.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.MetadataTimeoutMilliseconds">
            <summary>
            The amount of time to wait if there are concurrent metadata access operations
            </summary>
        </member>
        <member name="E:ProtoBuf.Meta.RuntimeTypeModel.LockContended">
            <summary>
            If a lock-contention is detected, this event signals the *owner* of the lock responsible for the blockage, indicating
            what caused the problem; this is only raised if the lock-owning code successfully completes.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions">
            <summary>
            Represents configuration options for compiling a model to 
            a standalone assembly.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.SetFrameworkOptions(ProtoBuf.Meta.MetaType)">
            <summary>
            Import framework options from an existing type
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TargetFrameworkName">
            <summary>
            The TargetFrameworkAttribute FrameworkName value to burn into the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TargetFrameworkDisplayName">
            <summary>
            The TargetFrameworkAttribute FrameworkDisplayName value to burn into the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TypeName">
            <summary>
            The name of the TypeModel class to create
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.OutputPath">
            <summary>
            The path for the new dll
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.ImageRuntimeVersion">
            <summary>
            The runtime version for the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.MetaDataVersion">
            <summary>
            The runtime version for the generated assembly
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.Accessibility">
            <summary>
            The acecssibility of the generated serializer
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.RuntimeTypeModel.Accessibility">
            <summary>
            Type accessibility
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.RuntimeTypeModel.Accessibility.Public">
            <summary>
            Available to all callers
            </summary>
        </member>
        <member name="F:ProtoBuf.Meta.RuntimeTypeModel.Accessibility.Internal">
            <summary>
            Available to all callers in the same assembly, or assemblies specified via [InternalsVisibleTo(...)]
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.LockContentedEventArgs">
            <summary>
            Contains the stack-trace of the owning code when a lock-contention scenario is detected
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.LockContentedEventArgs.OwnerStackTrace">
            <summary>
            The stack-trace of the code that owned the lock when a lock-contention scenario occurred
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.LockContentedEventHandler">
            <summary>
            Event-type that is raised when a lock-contention scenario is detected
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.SubType">
            <summary>
            Represents an inherited type in a type hierarchy.
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.SubType.#ctor(System.Int32,ProtoBuf.Meta.MetaType,ProtoBuf.DataFormat)">
            <summary>
            Creates a new SubType instance.
            </summary>
            <param name="fieldNumber">The field-number that is used to encapsulate the data (as a nested
            message) for the derived dype.</param>
            <param name="derivedType">The sub-type to be considered.</param>
            <param name="format">Specific encoding style to use; in particular, Grouped can be used to avoid buffering, but is not the default.</param>
        </member>
        <member name="P:ProtoBuf.Meta.SubType.FieldNumber">
            <summary>
            The field-number that is used to encapsulate the data (as a nested
            message) for the derived dype.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.SubType.DerivedType">
            <summary>
            The sub-type to be considered.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeFormatEventArgs">
            <summary>
            Event arguments needed to perform type-formatting functions; this could be resolving a Type to a string suitable for serialization, or could
            be requesting a Type from a string. If no changes are made, a default implementation will be used (from the assembly-qualified names).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeFormatEventArgs.Type">
            <summary>
            The type involved in this map; if this is initially null, a Type is expected to be provided for the string in FormattedName.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.TypeFormatEventArgs.FormattedName">
            <summary>
            The formatted-name involved in this map; if this is initially null, a formatted-name is expected from the type in Type.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.TypeFormatEventHandler">
            <summary>
            Delegate type used to perform type-formatting functions; the sender originates as the type-model.
            </summary>
        </member>
        <member name="T:ProtoBuf.Meta.ValueMember">
            <summary>
            Represents a member (property/field) that is mapped to a protobuf field
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.#ctor(ProtoBuf.Meta.RuntimeTypeModel,System.Type,System.Int32,System.Reflection.MemberInfo,System.Type,System.Type,System.Type,ProtoBuf.DataFormat,System.Object)">
            <summary>
            Creates a new ValueMember instance
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.#ctor(ProtoBuf.Meta.RuntimeTypeModel,System.Int32,System.Type,System.Type,System.Type,ProtoBuf.DataFormat)">
            <summary>
            Creates a new ValueMember instance
            </summary>
        </member>
        <member name="M:ProtoBuf.Meta.ValueMember.SetSpecified(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Specifies methods for working with optional data members.
            </summary>
            <param name="getSpecified">Provides a method (null for none) to query whether this member should
            be serialized; it must be of the form "bool {Method}()". The member is only serialized if the
            method returns true.</param>
            <param name="setSpecified">Provides a method (null for none) to indicate that a member was
            deserialized; it must be of the form "void {Method}(bool)", and will be called with "true"
            when data is found.</param>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.FieldNumber">
            <summary>
            The number that identifies this member in a protobuf stream
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.Member">
            <summary>
            Gets the member (field/property) which this member relates to.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.ItemType">
            <summary>
            Within a list / array / etc, the type of object for each item in the list (especially useful with ArrayList)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.MemberType">
            <summary>
            The underlying type of the member
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DefaultType">
            <summary>
            For abstract types (IList etc), the type of concrete object to create (if required)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.ParentType">
            <summary>
            The type the defines the member
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DefaultValue">
            <summary>
            The default value of the item (members with this value will not be serialized)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DataFormat">
            <summary>
            Specifies the rules used to process the field; this is used to determine the most appropriate
            wite-type, but also to describe subtypes <i>within</i> that wire-type (such as SignedVariant)
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsStrict">
            <summary>
            Indicates whether this field should follow strict encoding rules; this means (for example) that if a "fixed32"
            is encountered when "variant" is defined, then it will fail (throw an exception) when parsing. Note that
            when serializing the defined type is always used.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsPacked">
            <summary>
            Indicates whether this field should use packed encoding (which can save lots of space for repeated primitive values).
            This option only applies to list/array data of primitive types (int, double, etc).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.OverwriteList">
            <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.IsRequired">
            <summary>
            Indicates whether this field is mandatory.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.Name">
            <summary>
            Gets the logical name for this member in the schema (this is not critical for binary serialization, but may be used
            when inferring a schema).
            </summary>
        </member>
        <member name="P:ProtoBuf.Meta.ValueMember.SupportNull">
            <summary>
            Should lists have extended support for null values? Note this makes the serialization less efficient.
            </summary>
        </member>
        <member name="T:ProtoBuf.PrefixStyle">
            <summary>
            Specifies the type of prefix that should be applied to messages.
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.None">
            <summary>
            No length prefix is applied to the data; the data is terminated only be the end of the stream.
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Base128">
            <summary>
            A base-128 length prefix is applied to the data (efficient for short messages).
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Fixed32">
            <summary>
            A fixed-length (little-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
        </member>
        <member name="F:ProtoBuf.PrefixStyle.Fixed32BigEndian">
            <summary>
            A fixed-length (big-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoContractAttribute">
            <summary>
            Indicates that a type is defined for protocol-buffer serialization.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.Name">
            <summary>
            Gets or sets the defined name of the type.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFirstTag">
            <summary>
            Gets or sets the fist offset to use with implicit field tags;
            only uesd if ImplicitFields is set.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.UseProtoMembersOnly">
            <summary>
            If specified, alternative contract markers (such as markers for XmlSerailizer or DataContractSerializer) are ignored.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.IgnoreListHandling">
            <summary>
            If specified, do NOT treat this type as a list, even if it looks like one.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFields">
            <summary>
            Gets or sets the mechanism used to automatically infer field tags
            for members. This option should be used in advanced scenarios only.
            Please review the important notes against the ImplicitFields enumeration.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.InferTagFromName">
            <summary>
            Enables/disables automatic tag generation based on the existing name / order
            of the defined members. This option is not used for members marked
            with ProtoMemberAttribute, as intended to provide compatibility with
            WCF serialization. WARNING: when adding new fields you must take
            care to increase the Order for new elements, otherwise data corruption
            may occur.
            </summary>
            <remarks>If not explicitly specified, the default is assumed from Serializer.GlobalOptions.InferTagFromName.</remarks>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.InferTagFromNameHasValue">
            <summary>
            Has a InferTagFromName value been explicitly set? if not, the default from the type-model is assumed.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.DataMemberOffset">
            <summary>
            Specifies an offset to apply to [DataMember(Order=...)] markers;
            this is useful when working with mex-generated classes that have
            a different origin (usually 1 vs 0) than the original data-contract.
            
            This value is added to the Order of each member.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.SkipConstructor">
            <summary>
            If true, the constructor for the type is bypassed during deserialization, meaning any field initializers
            or other initialization code is skipped.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoContractAttribute.AsReferenceDefault">
            <summary>
            Should this type be treated as a reference by default? Please also see the implications of this,
            as recorded on ProtoMemberAttribute.AsReference
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoEnumAttribute">
            <summary>
            Used to define protocol-buffer specific behavior for
            enumerated values.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoEnumAttribute.HasValue">
            <summary>
            Indicates whether this instance has a customised value mapping
            </summary>
            <returns>true if a specific value is set</returns>
        </member>
        <member name="P:ProtoBuf.ProtoEnumAttribute.Value">
            <summary>
            Gets or sets the specific value to use for this enum during serialization.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoEnumAttribute.Name">
            <summary>
            Gets or sets the defined name of the enum, as used in .proto
            (this name is not used during serialization).
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoException">
            <summary>
            Indicates an error during serialization/deserialization of a proto stream.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor(System.String)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:ProtoBuf.ProtoException.#ctor(System.String,System.Exception)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="T:ProtoBuf.ProtoIgnoreAttribute">
            <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoPartialIgnoreAttribute">
            <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields. This allows
            ProtoIgnoreAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoPartialIgnoreAttribute.#ctor(System.String)">
            <summary>
            Creates a new ProtoPartialIgnoreAttribute instance.
            </summary>
            <param name="memberName">Specifies the member to be ignored.</param>
        </member>
        <member name="P:ProtoBuf.ProtoPartialIgnoreAttribute.MemberName">
            <summary>
            The name of the member to be ignored.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoIncludeAttribute">
            <summary>
            Indicates the known-types to support for an individual
            message. This serializes each level in the hierarchy as
            a nested message to retain wire-compatibility with
            other protocol-buffer implementations.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.Type)">
            <summary>
             Creates a new instance of the ProtoIncludeAttribute.
             </summary>
             <param name="tag">The unique index (within the type) that will identify this data.</param>
             <param name="knownType">The additional type to serialize/deserialize.</param>
        </member>
        <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new instance of the ProtoIncludeAttribute.
            </summary>
            <param name="tag">The unique index (within the type) that will identify this data.</param>
            <param name="knownTypeName">The additional type to serialize/deserialize.</param>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.Tag">
            <summary>
            Gets the unique index (within the type) that will identify this data.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownTypeName">
            <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownType">
            <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoIncludeAttribute.DataFormat">
            <summary>
            Specifies whether the inherited sype's sub-message should be
            written with a length-prefix (default), or with group markers.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoMemberAttribute">
            <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag. A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.CompareTo(System.Object)">
            <summary>
            Compare with another ProtoMemberAttribute for sorting purposes
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.CompareTo(ProtoBuf.ProtoMemberAttribute)">
            <summary>
            Compare with another ProtoMemberAttribute for sorting purposes
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoMemberAttribute.#ctor(System.Int32)">
            <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
            <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Name">
            <summary>
            Gets or sets the original name defined in the .proto; not used
            during serialization.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.DataFormat">
            <summary>
            Gets or sets the data-format to be used when encoding this value.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Tag">
            <summary>
            Gets the unique tag used to identify this member within the type.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.IsRequired">
            <summary>
            Gets or sets a value indicating whether this member is mandatory.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.IsPacked">
            <summary>
            Gets a value indicating whether this member is packed.
            This option only applies to list/array data of primitive types (int, double, etc).
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.OverwriteList">
            <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.AsReference">
            <summary>
            Enables full object-tracking/full-graph support.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoMemberAttribute.Options">
            <summary>
            Gets or sets a value indicating whether this member is packed (lists/arrays).
            </summary>
        </member>
        <member name="T:ProtoBuf.MemberSerializationOptions">
            <summary>
            Additional (optional) settings that control serialization of members
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.None">
            <summary>
            Default; no additional options
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.Packed">
            <summary>
            Indicates that repeated elements should use packed (length-prefixed) encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.Required">
            <summary>
            Indicates that the given item is required
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.AsReference">
            <summary>
            Enables full object-tracking/full-graph support
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.DynamicType">
            <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.OverwriteList">
            <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
        </member>
        <member name="F:ProtoBuf.MemberSerializationOptions.AsReferenceHasValue">
            <summary>
            Determines whether the types AsReferenceDefault value is used, or whether this member's AsReference should be used
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoPartialMemberAttribute">
            <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag and MemberName. This allows ProtoMemberAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoPartialMemberAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
            <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
            <param name="memberName">Specifies the member to be serialized.</param>
        </member>
        <member name="P:ProtoBuf.ProtoPartialMemberAttribute.MemberName">
            <summary>
            The name of the member to be serialized.
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoReader">
            <summary>
            A stateful reader, used to read a protobuf stream. Typical usage would be (sequentially) to call
            ReadFieldHeader and (after matching the field) an appropriate Read* method.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
        </member>
        <member name="M:ProtoBuf.ProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext,System.Int32)">
            <summary>
            Creates a new reader against a stream
            </summary>
            <param name="source">The source stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
            <param name="length">The number of bytes to read, or -1 to read until the end of the stream</param>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Dispose">
            <summary>
            Releases resources used by the reader, but importantly <b>does not</b> Dispose the 
            underlying stream; in many typical use-cases the stream is used for different
            processes, so it is assumed that the consumer will Dispose their stream separately.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt32">
            <summary>
            Reads an unsigned 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt16">
            <summary>
            Reads a signed 16-bit integer from the stream: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt16">
            <summary>
            Reads an unsigned 16-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadByte">
            <summary>
            Reads an unsigned 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadSByte">
            <summary>
            Reads a signed 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt32">
            <summary>
            Reads a signed 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadInt64">
            <summary>
            Reads a signed 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadString">
            <summary>
            Reads a string from the stream (using UTF8); supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ThrowEnumException(System.Type,System.Int32)">
            <summary>
            Throws an exception indication that the given value cannot be mapped to an enum.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadDouble">
            <summary>
            Reads a double-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadObject(System.Object,System.Int32,ProtoBuf.ProtoReader)">
            <summary>
            Reads (merges) a sub-message from the stream, internally calling StartSubItem and EndSubItem, and (in between)
            parsing the message in accordance with the model associated with the reader
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.EndSubItem(ProtoBuf.SubItemToken,ProtoBuf.ProtoReader)">
            <summary>
            Makes the end of consuming a nested message in the stream; the stream must be either at the correct EndGroup
            marker, or all fields of the sub-message must have been consumed (in either case, this means ReadFieldHeader
            should return zero)
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.StartSubItem(ProtoBuf.ProtoReader)">
            <summary>
            Begins consuming a nested message in the stream; supported wire-types: StartGroup, String
            </summary>
            <remarks>The token returned must be help and used when callining EndSubItem</remarks>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadFieldHeader">
            <summary>
            Reads a field header from the stream, setting the wire-type and retuning the field number. If no
            more fields are available, then 0 is returned. This methods respects sub-messages.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.TryReadFieldHeader(System.Int32)">
            <summary>
            Looks ahead to see whether the next field in the stream is what we expect
            (typically; what we've just finished reading - for example ot read successive list items)
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Hint(ProtoBuf.WireType)">
            <summary>
            Compares the streams current wire-type to the hinted wire-type, updating the reader if necessary; for example,
            a Variant may be updated to SignedVariant. If the hinted wire-type is unrelated then no change is made.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Assert(ProtoBuf.WireType)">
            <summary>
            Verifies that the stream's current wire-type is as expected, or a specialized sub-type (for example,
            SignedVariant) - in which case the current wire-type is updated. Otherwise an exception is thrown.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.SkipField">
            <summary>
            Discards the data for the current field.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadUInt64">
            <summary>
            Reads an unsigned 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadSingle">
            <summary>
            Reads a single-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadBoolean">
            <summary>
            Reads a boolean value from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
            <returns></returns>
        </member>
        <member name="M:ProtoBuf.ProtoReader.AppendBytes(System.Byte[],ProtoBuf.ProtoReader)">
            <summary>
            Reads a byte-sequence from the stream, appending them to an existing byte-sequence (which can be null); supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadLittleEndianInt32(System.IO.Stream)">
            <summary>
            Reads a little-endian encoded integer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadBigEndianInt32(System.IO.Stream)">
            <summary>
            Reads a big-endian encoded integer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadVarintInt32(System.IO.Stream)">
            <summary>
            Reads a varint encoded integer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadBytes(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a string (of a given lenth, in bytes) directly from the source into a pre-existing buffer. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadBytes(System.IO.Stream,System.Int32)">
            <summary>
            Reads a given number of bytes directly from the source. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.DirectReadString(System.IO.Stream,System.Int32)">
            <summary>
            Reads a string (of a given lenth, in bytes) directly from the source. An exception is thrown if the data is not all available.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@,System.Int32@)">
            <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.TryReadUInt32Variant(System.IO.Stream,System.UInt32@)">
            <returns>The number of bytes consumed; 0 if no data available</returns>
        </member>
        <member name="M:ProtoBuf.ProtoReader.AppendExtensionData(ProtoBuf.IExtensible)">
            <summary>
            Copies the current field into the instance as extension data
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.HasSubValue(ProtoBuf.WireType,ProtoBuf.ProtoReader)">
            <summary>
            Indicates whether the reader still has data remaining in the current sub-item,
            additionally setting the wire-type for the next field if there is more data.
            This is used when decoding packed data.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.NoteObject(System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Utility method, not intended for public use; this helps maintain the root object is complex scenarios
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.ReadType">
            <summary>
            Reads a Type from the stream, using the model's DynamicTypeFormatting if appropriate; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoReader.Merge(ProtoBuf.ProtoReader,System.Object,System.Object)">
            <summary>
            Merge two objects using the details from the current reader; this is used to change the type
            of objects when an inheritance relationship is discovered later than usual during deserilazation.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.FieldNumber">
            <summary>
            Gets the number of the field being processed.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.WireType">
            <summary>
            Indicates the underlying proto serialization format on the wire.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.InternStrings">
            <summary>
            Gets / sets a flag indicating whether strings should be checked for repetition; if
            true, any repeated UTF-8 byte sequence will result in the same String instance, rather
            than a second instance of the same string. Enabled by default. Note that this uses
            a <i>custom</i> interner - the system-wide string interner is not used.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Context">
            <summary>
            Addition information about this deserialization operation.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Position">
            <summary>
            Returns the position of the current reader (note that this is not necessarily the same as the position
            in the underlying stream, if multiple readers are used on the same stream)
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoReader.Model">
            <summary>
            Get the TypeModel associated with this reader
            </summary>
        </member>
        <member name="T:ProtoBuf.ProtoWriter">
            <summary>
            Represents an output stream for writing protobuf data.
            
            Why is the API backwards (static methods with writer arguments)?
            See: http://marcgravell.blogspot.com/2010/03/last-will-be-first-and-first-will-be.html
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteObject(System.Object,System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Write an encapsulated sub-object, using the supplied unique key (reprasenting a type).
            </summary>
            <param name="value">The object to write.</param>
            <param name="key">The key that uniquely identifies the type within the model.</param>
            <param name="writer">The destination.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteRecursionSafeObject(System.Object,System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Write an encapsulated sub-object, using the supplied unique key (reprasenting a type) - but the
            caller is asserting that this relationship is non-recursive; no recursion check will be
            performed.
            </summary>
            <param name="value">The object to write.</param>
            <param name="key">The key that uniquely identifies the type within the model.</param>
            <param name="writer">The destination.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteFieldHeader(System.Int32,ProtoBuf.WireType,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a field-header, indicating the format of the next data we plan to write.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBytes(System.Byte[],ProtoBuf.ProtoWriter)">
            <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBytes(System.Byte[],System.Int32,System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.StartSubItem(System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Indicates the start of a nested record.
            </summary>
            <param name="instance">The instance to write.</param>
            <param name="writer">The destination.</param>
            <returns>A token representing the state of the stream; this token is given to EndSubItem.</returns>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.EndSubItem(ProtoBuf.SubItemToken,ProtoBuf.ProtoWriter)">
            <summary>
            Indicates the end of a nested record.
            </summary>
            <param name="token">The token obtained from StartubItem.</param>
            <param name="writer">The destination.</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext)">
            <summary>
            Creates a new writer against a stream
            </summary>
            <param name="dest">The destination stream</param>
            <param name="model">The model to use for serialization; this can be null, but this will impair the ability to serialize sub-objects</param>
            <param name="context">Additional context about this serialization operation</param>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.Close">
            <summary>
            Flushes data to the underlying stream, and releases any resources. The underlying stream is *not* disposed
            by this operation.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.Flush(ProtoBuf.ProtoWriter)">
            <summary>
            Writes any buffered data (if possible) to the underlying stream.
            </summary>
            <param name="writer">The writer to flush</param>
            <remarks>It is not always possible to fully flush, since some sequences
            may require values to be back-filled into the byte-stream.</remarks>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt32Variant(System.UInt32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 32-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteString(System.String,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a string to the stream; supported wire-types: String
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt64(System.UInt64,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt64(System.Int64,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt32(System.UInt32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt16(System.Int16,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteUInt16(System.UInt16,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteByte(System.Byte,ProtoBuf.ProtoWriter)">
            <summary>
            Writes an unsigned 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteSByte(System.SByte,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteInt32(System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a signed 32-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteDouble(System.Double,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a double-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteSingle(System.Single,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a single-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.ThrowEnumException(ProtoBuf.ProtoWriter,System.Object)">
            <summary>
            Throws an exception indicating that the given enum cannot be mapped to a serialized value.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteBoolean(System.Boolean,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a boolean to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.AppendExtensionData(ProtoBuf.IExtensible,ProtoBuf.ProtoWriter)">
            <summary>
            Copies any extension data stored for the instance to the underlying stream
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.SetPackedField(System.Int32,ProtoBuf.ProtoWriter)">
            <summary>
            Used for packed encoding; indicates that the next field should be skipped rather than
            a field header written. Note that the field number must match, else an exception is thrown
            when the attempt is made to write the (incorrect) field. The wire-type is taken from the
            subsequent call to WriteFieldHeader. Only primitive types can be packed.
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.SetRootObject(System.Object)">
            <summary>
            Specifies a known root object to use during reference-tracked serialization
            </summary>
        </member>
        <member name="M:ProtoBuf.ProtoWriter.WriteType(System.Type,ProtoBuf.ProtoWriter)">
            <summary>
            Writes a Type to the stream, using the model's DynamicTypeFormatting if appropriate; supported wire-types: String
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoWriter.Context">
            <summary>
            Addition information about this serialization operation.
            </summary>
        </member>
        <member name="P:ProtoBuf.ProtoWriter.Model">
            <summary>
            Get the TypeModel associated with this writer
            </summary>
        </member>
        <member name="T:ProtoBuf.SerializationContext">
            <summary>
            Additional information about a serialization operation
            </summary>
        </member>
        <member name="M:ProtoBuf.SerializationContext.op_Implicit(ProtoBuf.SerializationContext)~System.Runtime.Serialization.StreamingContext">
            <summary>
            Convert a SerializationContext to a StreamingContext
            </summary>
        </member>
        <member name="M:ProtoBuf.SerializationContext.op_Implicit(System.Runtime.Serialization.StreamingContext)~ProtoBuf.SerializationContext">
            <summary>
            Convert a StreamingContext to a SerializationContext
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.Context">
            <summary>
            Gets or sets a user-defined object containing additional information about this serialization/deserialization operation.
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.Default">
            <summary>
            A default SerializationContext, with minimal information.
            </summary>
        </member>
        <member name="P:ProtoBuf.SerializationContext.State">
            <summary>
            Gets or sets the source or destination of the transmitted data.
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer">
            <summary>
            Provides protocol-buffer serialization capability for concrete, attributed types. This
            is a *default* model, but custom serializer models are also supported.
            </summary>
            <remarks>
            Protocol-buffer serialization is a compact binary format, designed to take
            advantage of sparse data and knowledge of specific data types; it is also
            extensible, allowing a type to be deserialized / merged even if some data is
            not recognised.
            </remarks>
        </member>
        <member name="F:ProtoBuf.Serializer.ListItemTag">
            <summary>
            The field number that is used as a default when serializing/deserializing a list of objects.
            The data is treated as repeated message with field number 1.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.GetProto``1">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <typeparam name="T">The type to generate a .proto definition for</typeparam>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeepClone``1(``0)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.IO.Stream,``0)">
            <summary>
            Applies a protocol-buffer stream to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Deserialize``1(System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.IO.Stream,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.ChangeType``2(``0)">
            <summary>
            Serializes a given instance and deserializes it as a different type;
            this can be used to translate between wire-compatible objects (where
            two .NET types represent the same data), or to promote/demote a type
            through an inheritance hierarchy.
            </summary>
            <remarks>No assumption of compatibility is made between the types.</remarks>
            <typeparam name="TFrom">The type of the object being copied.</typeparam>
            <typeparam name="TTo">The type of the new object to be created.</typeparam>
            <param name="instance">The existing instance to use as a template.</param>
            <returns>A new instane of type TNewType, with the data from TOldType.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.Runtime.Serialization.SerializationInfo,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied SerializationInfo.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="info">The destination SerializationInfo to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied SerializationInfo.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="info">The destination SerializationInfo to write to.</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Serialize``1(System.Xml.XmlWriter,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied XmlWriter.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="writer">The destination XmlWriter to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.Xml.XmlReader,``0)">
            <summary>
            Applies a protocol-buffer from an XmlReader to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="reader">The XmlReader containing the data to apply to the instance (cannot be null).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.Runtime.Serialization.SerializationInfo,``0)">
            <summary>
            Applies a protocol-buffer from a SerializationInfo to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="info">The SerializationInfo containing the data to apply to the instance (cannot be null).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.Merge``1(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,``0)">
            <summary>
            Applies a protocol-buffer from a SerializationInfo to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="info">The SerializationInfo containing the data to apply to the instance (cannot be null).</param>
            <param name="context">Additional information about this serialization operation.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.PrepareSerializer``1">
            <summary>
            Precompiles the serializer for a given type.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.CreateFormatter``1">
            <summary>
            Creates a new IFormatter that uses protocol-buffer [de]serialization.
            </summary>
            <typeparam name="T">The type of object to be [de]deserialized by the formatter.</typeparam>
            <returns>A new IFormatter to be used during [de]serialization.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="fieldNumber">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle)">
            <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="fieldNumber">The expected tag of the item (only used with base-128 prefix style).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.MergeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
            <summary>
            Applies a protocol-buffer stream to an existing instance, using length-prefixed
            data - useful with network IO.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>Indicates the number of bytes expected for the next message.</summary>
            <param name="source">The stream containing the data to investigate for a length.</param>
            <param name="style">The algorithm used to encode the length.</param>
            <param name="length">The length of the message, if it could be identified.</param>
            <returns>True if a length could be obtained, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.Byte[],System.Int32,System.Int32,ProtoBuf.PrefixStyle,System.Int32@)">
            <summary>Indicates the number of bytes expected for the next message.</summary>
            <param name="buffer">The buffer containing the data to investigate for a length.</param>
            <param name="index">The offset of the first byte to read from the buffer.</param>
            <param name="count">The number of bytes to read from the buffer.</param>
            <param name="style">The algorithm used to encode the length.</param>
            <param name="length">The length of the message, if it could be identified.</param>
            <returns>True if a length could be obtained, false otherwise.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.FlushPool">
            <summary>
            Releases any internal buffers that have been reserved for efficiency; this does not affect any serialization
            operations; simply: it can be used (optionally) to release the buffers for garbage collection (at the expense
            of having to re-allocate a new buffer for the next operation, rather than re-use prior buffers).
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.NonGeneric">
            <summary>
            Provides non-generic access to the default serializer.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.DeepClone(System.Object)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="dest">The destination stream to write to.</param>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Deserialize(System.Type,System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <param name="type">The type to be created.</param>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.Merge(System.IO.Stream,System.Object)">
            <summary>Applies a protocol-buffer stream to an existing instance.</summary>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.SerializeWithLengthPrefix(System.IO.Stream,System.Object,ProtoBuf.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.TryDeserializeWithLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,ProtoBuf.Serializer.TypeResolver,System.Object@)">
            <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
            <param name="value">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="resolver">Used to resolve types on a per-field basis.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:ProtoBuf.Serializer.NonGeneric.CanSerialize(System.Type)">
            <summary>
            Indicates whether the supplied type is explicitly modelled by the model
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.GlobalOptions">
            <summary>
            Global switches that change the behavior of protobuf-net
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializer.GlobalOptions.InferTagFromName">
            <summary>
            <see cref="P:ProtoBuf.Meta.RuntimeTypeModel.InferTagFromNameDefault"/>
            </summary>
        </member>
        <member name="T:ProtoBuf.Serializer.TypeResolver">
            <summary>
            Maps a field-number to a type
            </summary>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.Write(System.Object,ProtoBuf.ProtoWriter)">
            <summary>
            Perform the steps necessary to serialize this data.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="dest">The writer entity that is accumulating the output data.</param>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.Read(System.Object,ProtoBuf.ProtoReader)">
            <summary>
            Perform the steps necessary to deserialize this data.
            </summary>
            <param name="value">The current value, if appropriate.</param>
            <param name="source">The reader providing the input data.</param>
            <returns>The updated / replacement value.</returns>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.EmitWrite(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
            <summary>Emit the IL necessary to perform the given actions
            to serialize this data.
            </summary>
            <param name="ctx">Details and utilities for the method being generated.</param>
            <param name="valueFrom">The source of the data to work against;
            If the value is only needed once, then LoadValue is sufficient. If
            the value is needed multiple times, then note that a "null"
            means "the top of the stack", in which case you should create your
            own copy - GetLocalWithValue.</param>
        </member>
        <member name="M:ProtoBuf.Serializers.IProtoSerializer.EmitRead(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
            <summary>
            Emit the IL necessary to perform the given actions to deserialize this data.
            </summary>
            <param name="ctx">Details and utilities for the method being generated.</param>
            <param name="entity">For nested values, the instance holding the values; note
            that this is not always provided - a null means not supplied. Since this is always
            a variable or argument, it is not necessary to consume this value.</param>
        </member>
        <member name="P:ProtoBuf.Serializers.IProtoSerializer.ExpectedType">
            <summary>
            The type that this serializer is intended to work for.
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue">
            <summary>
            Indicates whether a Read operation <em>replaces</em> the existing value, or
            <em>extends</em> the value. If false, the "value" parameter to Read is
            discarded, and should be passed in as null.
            </summary>
        </member>
        <member name="P:ProtoBuf.Serializers.IProtoSerializer.ReturnsValue">
            <summary>
            Now all Read operations return a value (although most do); if false no
            value should be expected.
            </summary>
        </member>
        <member name="T:ProtoBuf.ServiceModel.ProtoBehaviorAttribute">
            <summary>
            Uses protocol buffer serialization on the specified operation; note that this
            must be enabled on both the client and server.
            </summary>
        </member>
        <member name="T:ProtoBuf.ServiceModel.ProtoBehaviorExtension">
            <summary>
            Configuration element to swap out DatatContractSerilaizer with the XmlProtoSerializer for a given endpoint.
            </summary>
            <seealso cref="T:ProtoBuf.ServiceModel.ProtoEndpointBehavior"/>
        </member>
        <member name="M:ProtoBuf.ServiceModel.ProtoBehaviorExtension.#ctor">
            <summary>
            Creates a new ProtoBehaviorExtension instance.
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.ProtoBehaviorExtension.CreateBehavior">
            <summary>
            Creates a behavior extension based on the current configuration settings.
            </summary>
            <returns>The behavior extension.</returns>
        </member>
        <member name="P:ProtoBuf.ServiceModel.ProtoBehaviorExtension.BehaviorType">
            <summary>
            Gets the type of behavior.
            </summary>     
        </member>
        <member name="T:ProtoBuf.ServiceModel.ProtoEndpointBehavior">
            <summary>
            Behavior to swap out DatatContractSerilaizer with the XmlProtoSerializer for a given endpoint.
             <example>
            Add the following to the server and client app.config in the system.serviceModel section:
             <behaviors>
               <endpointBehaviors>
                 <behavior name="ProtoBufBehaviorConfig">
                   <ProtoBufSerialization/>
                 </behavior>
               </endpointBehaviors>
             </behaviors>
             <extensions>
               <behaviorExtensions>
                 <add name="ProtoBufSerialization" type="ProtoBuf.ServiceModel.ProtoBehaviorExtension, protobuf-net, Version=1.0.0.255, Culture=neutral, PublicKeyToken=257b51d87d2e4d67"/>
               </behaviorExtensions>
             </extensions>
            
            Configure your endpoints to have a behaviorConfiguration as follows:
            
             <service name="TK.Framework.Samples.ServiceModel.Contract.SampleService">
               <endpoint address="http://myhost:9003/SampleService" binding="basicHttpBinding" behaviorConfiguration="ProtoBufBehaviorConfig"
                bindingConfiguration="basicHttpBindingConfig" name="basicHttpProtoBuf" contract="ISampleServiceContract" />
             </service>
             <client>
                 <endpoint address="http://myhost:9003/SampleService" binding="basicHttpBinding"
                     bindingConfiguration="basicHttpBindingConfig" contract="ISampleServiceContract"
                     name="BasicHttpProtoBufEndpoint" behaviorConfiguration="ProtoBufBehaviorConfig"/>
              </client>
            </example>
            </summary>
        </member>
        <member name="T:ProtoBuf.ServiceModel.ProtoOperationBehavior">
            <summary>
            Describes a WCF operation behaviour that can perform protobuf serialization
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.ProtoOperationBehavior.#ctor(System.ServiceModel.Description.OperationDescription)">
            <summary>
            Create a new ProtoOperationBehavior instance
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.ProtoOperationBehavior.CreateSerializer(System.Type,System.Xml.XmlDictionaryString,System.Xml.XmlDictionaryString,System.Collections.Generic.IList{System.Type})">
            <summary>
            Creates a protobuf serializer if possible (falling back to the default WCF serializer)
            </summary>
        </member>
        <member name="P:ProtoBuf.ServiceModel.ProtoOperationBehavior.Model">
            <summary>
            The type-model that should be used with this behaviour
            </summary>
        </member>
        <member name="T:ProtoBuf.ServiceModel.XmlProtoSerializer">
            <summary>
            An xml object serializer that can embed protobuf data in a base-64 hunk (looking like a byte[])
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.TryCreate(ProtoBuf.Meta.TypeModel,System.Type)">
            <summary>
            Attempt to create a new serializer for the given model and type
            </summary>
            <returns>A new serializer instance if the type is recognised by the model; null otherwise</returns>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.#ctor(ProtoBuf.Meta.TypeModel,System.Type)">
            <summary>
            Creates a new serializer for the given model and type
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.WriteEndObject(System.Xml.XmlDictionaryWriter)">
            <summary>
            Ends an object in the output
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.WriteStartObject(System.Xml.XmlDictionaryWriter,System.Object)">
            <summary>
            Begins an object in the output
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.WriteObjectContent(System.Xml.XmlDictionaryWriter,System.Object)">
            <summary>
            Writes the body of an object in the output
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.IsStartObject(System.Xml.XmlDictionaryReader)">
            <summary>
            Indicates whether this is the start of an object we are prepared to handle
            </summary>
        </member>
        <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.ReadObject(System.Xml.XmlDictionaryReader,System.Boolean)">
            <summary>
            Reads the body of an object
            </summary>
        </member>
        <member name="T:ProtoBuf.SubItemToken">
            <summary>
            Used to hold particulars relating to nested objects. This is opaque to the caller - simply
            give back the token you are given at the end of an object.
            </summary>
        </member>
        <member name="T:ProtoBuf.WireType">
            <summary>
            Indicates the encoding used to represent an individual value in a protobuf stream
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.None">
            <summary>
            Represents an error condition
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Variant">
            <summary>
            Base-128 variant-length encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Fixed64">
            <summary>
            Fixed-length 8-byte encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.String">
            <summary>
            Length-variant-prefixed encoding
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.StartGroup">
            <summary>
            Indicates the start of a group
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.EndGroup">
            <summary>
            Indicates the end of a group
            </summary>
        </member>
        <member name="F:ProtoBuf.WireType.Fixed32">
            <summary>
            Fixed-length 4-byte encoding
            </summary>10
        </member>
        <member name="F:ProtoBuf.WireType.SignedVariant">
            <summary>
            This is not a formal wire-type in the "protocol buffers" spec, but
            denotes a variant integer that should be interpreted using
            zig-zag semantics (so -ve numbers aren't a significant overhead)
            </summary>
        </member>
        <member name="T:VRage.ConstructorHelper`1">
            <summary>
            Helpers for constructor.
            </summary>
            <typeparam name="T">Type of object</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VRage.ConstructorHelper`1.CreateInPlaceConstructor(System.Type)" -->
        <member name="M:VRage.Security.Md5.RotateLeft(System.UInt32,System.UInt16)">
            <summary>
            Left rotates the input word
            </summary>
            <param name="uiNumber">a value to be rotated</param>
            <param name="shift">no of bits to be rotated</param>
            <returns>the rotated value</returns>
        </member>
        <member name="F:VRage.Security.Md5.T">
            <summary>
            lookup table 4294967296*sin(i)
            </summary>
        </member>
        <member name="M:VRage.Security.Md5.ComputeHash(System.Byte[])">
            <summary>
            calculat md5 signature of the string in Input
            </summary>
            <returns> Digest: the finger print of msg</returns>
        </member>
        <member name="M:VRage.Security.Md5.ComputeHash(System.Byte[],VRage.Security.Md5.Hash)">
            <summary>
            calculat md5 signature of the string in Input
            </summary>
            <returns> Digest: the finger print of msg</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VRage.Security.Md5.TransF(System.UInt32@,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt16,System.UInt32,System.UInt32*)" -->
        <!-- Badly formed XML comment ignored for member "M:VRage.Security.Md5.TransG(System.UInt32@,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt16,System.UInt32,System.UInt32*)" -->
        <member name="M:VRage.Security.Md5.TransH(System.UInt32@,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt16,System.UInt32,System.UInt32*)">
            <summary>
            perform transformatio using h(b^c^d)
            </summary>
        </member>
        <member name="M:VRage.Security.Md5.TransI(System.UInt32@,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt16,System.UInt32,System.UInt32*)">
            <summary>
            perform transformatio using i (c^(b|~d))
            </summary>
        </member>
        <member name="M:VRage.Security.Md5.PerformTransformation(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32*)">
            <summary>
            Perform All the transformation on the data
            </summary>
            <param name="A">A</param>
            <param name="B">B </param>
            <param name="C">C</param>
            <param name="D">D</param>
        </member>
        <member name="M:VRage.Security.Md5.CopyBlock(System.Byte[],System.UInt32,System.UInt32*)">
            <summary>
            Copies a 512 bit block into X as 16 32 bit words
            </summary>
            <param name="bMsg"> source buffer</param>
            <param name="block">no of block to copy starting from 0</param>
        </member>
        <member name="T:VRage.Security.Md5.Hash">
            <summary>
            Represent digest with ABCD
            </summary>
        </member>
        <member name="M:VRage.Security.Md5.Hash.ReverseByte(System.UInt32)">
            <summary>
            perform a ByteReversal on a number
            </summary>
            <param name="uiNumber">value to be reversed</param>
            <returns>reversed value</returns>
        </member>
        <member name="T:VRage.Serialization.BlitCollectionSerializer`2">
            <summary>
            This is not optimal in terms of allocations, but works fine
            </summary>
        </member>
        <member name="M:VRage.ByteStream.#ctor(System.Int32,System.Boolean)">
            <summary>
            Create non-resetable Stream, optionally expandable
            </summary>
        </member>
        <member name="M:VRage.ByteStream.#ctor">
            <summary>
            Creates resetable Stream
            </summary>
        </member>
        <member name="M:VRage.ByteStream.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates and initializes resetable Stream
            </summary>
        </member>
        <member name="M:VRage.ByteStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Original C# implementation
            </summary>
        </member>
        <member name="M:VRage.ByteStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Original C# implementation
            </summary>
        </member>
        <member name="T:VRage.Serialization.TupleSerializer">
            <summary>
            Serializer for empty class, does nothing
            </summary>
        </member>
        <member name="E:VRage.Service.ExitListenerSTA.OnExit">
            <summary>
            Raised when close message is sent to thread message pump (e.g. "taskkill.exe /im MyApp.exe")
            Use only in windowless applications!
            </summary>
        </member>
        <member name="M:VRage.Service.MyServiceBase.GetString(System.String)">
            <summary>
            Don't want to include resources, just return key
            </summary>
        </member>
        <member name="M:VRage.Service.MyServiceBase.GetString(System.String,System.Object[])">
            <summary>
            Don't want to include resources, just return key + args
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Clear">
            <summary>
            Clears all stats (doesn't remove them)
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.RemoveAll">
            <summary>
            Removes all stats
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Remove(System.String)">
            <summary>
            Remove a stat
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Increment(System.String,System.Int32,System.Int32)">
            <summary>
            Increments an internal counter with given name and sets it to refresh after given time has passed.
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Write(System.String,System.Single,VRage.Stats.MyStatTypeEnum,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write stat, colon and space is added automatically
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Write(System.String,System.Int64,VRage.Stats.MyStatTypeEnum,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write stat, colon and space is added automatically
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.WriteFormat(System.String,System.Single,VRage.Stats.MyStatTypeEnum,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write stat using format string
            Number of arguments in format string:
            MinMaxAvg - three
            MinMax - two
            Other - one
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.WriteFormat(System.String,System.Int64,VRage.Stats.MyStatTypeEnum,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write stat using format string
            Number of arguments in format string:
            MinMaxAvg - three
            MinMax - two
            Other - one
            </summary>
        </member>
        <member name="T:VRage.Common.Utils.MyChecksums">
            <summary>
            Helper class for serializing and deserializing checksum file.
            </summary>
        </member>
        <member name="F:VRage.Library.Utils.MyEnum`1.m_names">
            <summary>
            Cached strings to avoid ToString() calls. These values are not readable in obfuscated builds!
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.OpenRead(System.String)">
            <summary>
            Opens file for reading
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.OpenRead(System.String,System.String)">
            <summary>
            Opens file for reading, convenient method with two paths to combine
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.OpenWrite(System.String,System.IO.FileMode)">
            <summary>
            Creates or overwrites existing file
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.OpenWrite(System.String,System.String,System.IO.FileMode)">
            <summary>
            Creates or overwrites existing file, convenient method with two paths to combine
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.CheckFileWriteAccess(System.String)">
            <summary>
            Checks write access for file
            </summary>
        </member>
        <member name="T:VRage.Library.Utils.MyGameTimer">
            <summary>
            Global thread-safe timer.
            Time for update and time for draw must be copied at the beginning of update and draw.
            </summary>
        </member>
        <member name="F:VRage.Library.Utils.MyGameTimer.Frequency">
            <summary>
            Number of ticks per seconds
            </summary>
        </member>
        <member name="P:VRage.Library.Utils.MyGameTimer.ElapsedTimeSpan">
            <summary>
            This may not be accurate for large values - double accuracy
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyInterpolationQueue`1.DiscardOld(VRage.Library.Utils.MyTimeSpan)">
            <summary>
            Discards old samples, keeps at least 2 samples to be able to interpolate or extrapolate.
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyInterpolationQueue`1.AddSample(`0@,VRage.Library.Utils.MyTimeSpan)">
            <summary>
            Adds sample with timestamp, it must be larger than last timestamp!
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyInterpolationQueue`1.Interpolate(VRage.Library.Utils.MyTimeSpan,`0@)">
            <summary>
            Discards old frame (keeps one older) and interpolates between two samples using interpolator.
            Returns interpolator
            There must be at least one sample!
            </summary>
        </member>
        <member name="T:VRage.Library.Utils.MyRandom">
            <summary>
            Original C# implementation which allows settings the seed.
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyRandom.SetSeed(System.Int32)">
            <summary>
            Sets new seed, only use this method when you have separate instance of MyRandom.
            Setting seed for RNG used for EntityId without reverting to previous state is dangerous.
            Use PushSeed for EntityId random generator.
            </summary>
        </member>
        <member name="T:VRage.Library.Utils.MyTimer">
            <summary>
            Hi-resolution wait timer, internally uses multimedia timer
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyTimer.StartOneShot(System.Int32,VRage.Library.Utils.MyTimer.TimerEventHandler)">
            <summary>
            Starts one shot periodic timer.
            Handler must be STORED somewhere to prevent GC collection until it's called!
            </summary>
        </member>
        <member name="T:VRage.Library.Utils.MyTimeSpan">
            <summary>
            Hi-resolution time span. Beware: the resolution can be different on different systems!
            </summary>
        </member>
        <member name="P:VRage.Library.Utils.MyTimeSpan.TimeSpan">
            <summary>
            This may not be accurate for large values - double accuracy
            </summary>
        </member>
        <member name="P:VRage.Win32.WinApi.WorkingSet">
            <summary>
            Gets working set size without creating garbage, it's also faster.
            Environment.WorkingSet create garbage.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SystemCommands.SC_MAXIMIZE">
            <summary>
             Sent when form maximizes
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SystemCommands.SC_MAXIMIZE2">
            <summary>
             Sent when form maximizes because of doubcle click on caption
             JTE: Don't use this constant. As per the documentation, you
                  must mask off the last 4 bits of wParam by AND'ing it
                  with 0xFFF0. You can't assume the last 4 bits. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SystemCommands.SC_CLOSE">
            <summary>
             Closes the form
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SystemCommands.SC_RESTORE">
            <summary>
             Sent when form is maximized from the taskbar
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.SystemCommands.SC_RESTORE2">
            <summary>
             Sent when form maximizes because of doubcle click on caption
             JTE: Don't use this constant. As per the documentation, you
                  must mask off the last 4 bits of wParam by AND'ing it
                  with 0xFFF0. You can't assume the last 4 bits. 
            </summary>
        </member>
        <member name="T:VRage.Win32.WinApi.WM">
            <summary>
            Windows Messages
            Defined in winuser.h from Windows SDK v6.1
            Documentation pulled from MSDN.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NULL">
            <summary>
            The WM_NULL message performs no operation. An application sends the WM_NULL message if it wants to post a message that the recipient window will ignore.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CREATE">
            <summary>
            The WM_CREATE message is sent when an application requests that a window be created by calling the CreateWindowEx or CreateWindow function. (The message is sent before the function returns.) The window procedure of the new window receives this message after the window is created, but before the window becomes visible.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DESTROY">
            <summary>
            The WM_DESTROY message is sent when a window is being destroyed. It is sent to the window procedure of the window being destroyed after the window is removed from the screen. 
            This message is sent first to the window being destroyed and then to the child windows (if any) as they are destroyed. During the processing of the message, it can be assumed that all child windows still exist.
            /// </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOVE">
            <summary>
            The WM_MOVE message is sent after a window has been moved. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SIZE">
            <summary>
            The WM_SIZE message is sent to a window after its size has changed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ACTIVATE">
            <summary>
            The WM_ACTIVATE message is sent to both the window being activated and the window being deactivated. If the windows use the same input queue, the message is sent synchronously, first to the window procedure of the top-level window being deactivated, then to the window procedure of the top-level window being activated. If the windows use different input queues, the message is sent asynchronously, so the window is activated immediately. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETFOCUS">
            <summary>
            The WM_SETFOCUS message is sent to a window after it has gained the keyboard focus. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.KILLFOCUS">
            <summary>
            The WM_KILLFOCUS message is sent to a window immediately before it loses the keyboard focus. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ENABLE">
            <summary>
            The WM_ENABLE message is sent when an application changes the enabled state of a window. It is sent to the window whose enabled state is changing. This message is sent before the EnableWindow function returns, but after the enabled state (WS_DISABLED style bit) of the window has changed. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETREDRAW">
            <summary>
            An application sends the WM_SETREDRAW message to a window to allow changes in that window to be redrawn or to prevent changes in that window from being redrawn. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETTEXT">
            <summary>
            An application sends a WM_SETTEXT message to set the text of a window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETTEXT">
            <summary>
            An application sends a WM_GETTEXT message to copy the text that corresponds to a window into a buffer provided by the caller. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETTEXTLENGTH">
            <summary>
            An application sends a WM_GETTEXTLENGTH message to determine the length, in characters, of the text associated with a window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PAINT">
            <summary>
            The WM_PAINT message is sent when the system or another application makes a request to paint a portion of an application's window. The message is sent when the UpdateWindow or RedrawWindow function is called, or by the DispatchMessage function when the application obtains a WM_PAINT message by using the GetMessage or PeekMessage function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CLOSE">
            <summary>
            The WM_CLOSE message is sent as a signal that a window or an application should terminate.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUERYENDSESSION">
            <summary>
            The WM_QUERYENDSESSION message is sent when the user chooses to end the session or when an application calls one of the system shutdown functions. If any application returns zero, the session is not ended. The system stops sending WM_QUERYENDSESSION messages as soon as one application returns zero.
            After processing this message, the system sends the WM_ENDSESSION message with the wParam parameter set to the results of the WM_QUERYENDSESSION message.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUERYOPEN">
            <summary>
            The WM_QUERYOPEN message is sent to an icon when the user requests that the window be restored to its previous size and position.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ENDSESSION">
            <summary>
            The WM_ENDSESSION message is sent to an application after the system processes the results of the WM_QUERYENDSESSION message. The WM_ENDSESSION message informs the application whether the session is ending.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUIT">
            <summary>
            The WM_QUIT message indicates a request to terminate an application and is generated when the application calls the PostQuitMessage function. It causes the GetMessage function to return zero.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ERASEBKGND">
            <summary>
            The WM_ERASEBKGND message is sent when the window background must be erased (for example, when a window is resized). The message is sent to prepare an invalidated portion of a window for painting. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSCOLORCHANGE">
            <summary>
            This message is sent to all top-level windows when a change is made to a system color setting. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SHOWWINDOW">
            <summary>
            The WM_SHOWWINDOW message is sent to a window when the window is about to be hidden or shown.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.WININICHANGE">
            <summary>
            An application sends the WM_WININICHANGE message to all top-level windows after making a change to the WIN.INI file. The SystemParametersInfo function sends this message after an application uses the function to change a setting in WIN.INI.
            Note  The WM_WININICHANGE message is provided only for compatibility with earlier versions of the system. Applications should use the WM_SETTINGCHANGE message.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETTINGCHANGE">
            <summary>
            An application sends the WM_WININICHANGE message to all top-level windows after making a change to the WIN.INI file. The SystemParametersInfo function sends this message after an application uses the function to change a setting in WIN.INI.
            Note  The WM_WININICHANGE message is provided only for compatibility with earlier versions of the system. Applications should use the WM_SETTINGCHANGE message.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DEVMODECHANGE">
            <summary>
            The WM_DEVMODECHANGE message is sent to all top-level windows whenever the user changes device-mode settings. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ACTIVATEAPP">
            <summary>
            The WM_ACTIVATEAPP message is sent when a window belonging to a different application than the active window is about to be activated. The message is sent to the application whose window is being activated and to the application whose window is being deactivated.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.FONTCHANGE">
            <summary>
            An application sends the WM_FONTCHANGE message to all top-level windows in the system after changing the pool of font resources. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.TIMECHANGE">
            <summary>
            A message that is sent whenever there is a change in the system time.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CANCELMODE">
            <summary>
            The WM_CANCELMODE message is sent to cancel certain modes, such as mouse capture. For example, the system sends this message to the active window when a dialog box or message box is displayed. Certain functions also send this message explicitly to the specified window regardless of whether it is the active window. For example, the EnableWindow function sends this message when disabling the specified window.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETCURSOR">
            <summary>
            The WM_SETCURSOR message is sent to a window if the mouse causes the cursor to move within a window and mouse input is not captured. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSEACTIVATE">
            <summary>
            The WM_MOUSEACTIVATE message is sent when the cursor is in an inactive window and the user presses a mouse button. The parent window receives this message only if the child window passes it to the DefWindowProc function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CHILDACTIVATE">
            <summary>
            The WM_CHILDACTIVATE message is sent to a child window when the user clicks the window's title bar or when the window is activated, moved, or sized.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUEUESYNC">
            <summary>
            The WM_QUEUESYNC message is sent by a computer-based training (CBT) application to separate user-input messages from other messages sent through the WH_JOURNALPLAYBACK Hook procedure. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETMINMAXINFO">
            <summary>
            The WM_GETMINMAXINFO message is sent to a window when the size or position of the window is about to change. An application can use this message to override the window's default maximized size and position, or its default minimum or maximum tracking size. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PAINTICON">
            <summary>
            Windows NT 3.51 and earlier: The WM_PAINTICON message is sent to a minimized window when the icon is to be painted. This message is not sent by newer versions of Microsoft Windows, except in unusual circumstances explained in the Remarks.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ICONERASEBKGND">
            <summary>
            Windows NT 3.51 and earlier: The WM_ICONERASEBKGND message is sent to a minimized window when the background of the icon must be filled before painting the icon. A window receives this message only if a class icon is defined for the window; otherwise, WM_ERASEBKGND is sent. This message is not sent by newer versions of Windows.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NEXTDLGCTL">
            <summary>
            The WM_NEXTDLGCTL message is sent to a dialog box procedure to set the keyboard focus to a different control in the dialog box. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SPOOLERSTATUS">
            <summary>
            The WM_SPOOLERSTATUS message is sent from Print Manager whenever a job is added to or removed from the Print Manager queue. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DRAWITEM">
            <summary>
            The WM_DRAWITEM message is sent to the parent window of an owner-drawn button, combo box, list box, or menu when a visual aspect of the button, combo box, list box, or menu has changed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MEASUREITEM">
            <summary>
            The WM_MEASUREITEM message is sent to the owner window of a combo box, list box, list view control, or menu item when the control or menu is created.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DELETEITEM">
            <summary>
            Sent to the owner of a list box or combo box when the list box or combo box is destroyed or when items are removed by the LB_DELETESTRING, LB_RESETCONTENT, CB_DELETESTRING, or CB_RESETCONTENT message. The system sends a WM_DELETEITEM message for each deleted item. The system sends the WM_DELETEITEM message for any deleted list box or combo box item with nonzero item data.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.VKEYTOITEM">
            <summary>
            Sent by a list box with the LBS_WANTKEYBOARDINPUT style to its owner in response to a WM_KEYDOWN message. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CHARTOITEM">
            <summary>
            Sent by a list box with the LBS_WANTKEYBOARDINPUT style to its owner in response to a WM_CHAR message. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETFONT">
            <summary>
            An application sends a WM_SETFONT message to specify the font that a control is to use when drawing text. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETFONT">
            <summary>
            An application sends a WM_GETFONT message to a control to retrieve the font with which the control is currently drawing its text. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETHOTKEY">
            <summary>
            An application sends a WM_SETHOTKEY message to a window to associate a hot key with the window. When the user presses the hot key, the system activates the window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETHOTKEY">
            <summary>
            An application sends a WM_GETHOTKEY message to determine the hot key associated with a window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUERYDRAGICON">
            <summary>
            The WM_QUERYDRAGICON message is sent to a minimized (iconic) window. The window is about to be dragged by the user but does not have an icon defined for its class. An application can return a handle to an icon or cursor. The system displays this cursor or icon while the user drags the icon.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.COMPAREITEM">
            <summary>
            The system sends the WM_COMPAREITEM message to determine the relative position of a new item in the sorted list of an owner-drawn combo box or list box. Whenever the application adds a new item, the system sends this message to the owner of a combo box or list box created with the CBS_SORT or LBS_SORT style. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETOBJECT">
            <summary>
            Active Accessibility sends the WM_GETOBJECT message to obtain information about an accessible object contained in a server application. 
            Applications never send this message directly. It is sent only by Active Accessibility in response to calls to AccessibleObjectFromPoint, AccessibleObjectFromEvent, or AccessibleObjectFromWindow. However, server applications handle this message. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.COMPACTING">
            <summary>
            The WM_COMPACTING message is sent to all top-level windows when the system detects more than 12.5 percent of system time over a 30- to 60-second interval is being spent compacting memory. This indicates that system memory is low.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.COMMNOTIFY">
            <summary>
            WM_COMMNOTIFY is Obsolete for Win32-Based Applications
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.WINDOWPOSCHANGING">
            <summary>
            The WM_WINDOWPOSCHANGING message is sent to a window whose size, position, or place in the Z order is about to change as a result of a call to the SetWindowPos function or another window-management function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.WINDOWPOSCHANGED">
            <summary>
            The WM_WINDOWPOSCHANGED message is sent to a window whose size, position, or place in the Z order has changed as a result of a call to the SetWindowPos function or another window-management function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.POWER">
            <summary>
            Notifies applications that the system, typically a battery-powered personal computer, is about to enter a suspended mode.
            Use: POWERBROADCAST
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.COPYDATA">
            <summary>
            An application sends the WM_COPYDATA message to pass data to another application. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CANCELJOURNAL">
            <summary>
            The WM_CANCELJOURNAL message is posted to an application when a user cancels the application's journaling activities. The message is posted with a NULL window handle. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NOTIFY">
            <summary>
            Sent by a common control to its parent window when an event has occurred or the control requires some information. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INPUTLANGCHANGEREQUEST">
            <summary>
            The WM_INPUTLANGCHANGEREQUEST message is posted to the window with the focus when the user chooses a new input language, either with the hotkey (specified in the Keyboard control panel application) or from the indicator on the system taskbar. An application can accept the change by passing the message to the DefWindowProc function or reject the change (and prevent it from taking place) by returning immediately. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INPUTLANGCHANGE">
            <summary>
            The WM_INPUTLANGCHANGE message is sent to the topmost affected window after an application's input language has been changed. You should make any application-specific settings and pass the message to the DefWindowProc function, which passes the message to all first-level child windows. These child windows can pass the message to DefWindowProc to have it pass the message to their child windows, and so on. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.TCARD">
            <summary>
            Sent to an application that has initiated a training card with Microsoft Windows Help. The message informs the application when the user clicks an authorable button. An application initiates a training card by specifying the HELP_TCARD command in a call to the WinHelp function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.HELP">
            <summary>
            Indicates that the user pressed the F1 key. If a menu is active when F1 is pressed, WM_HELP is sent to the window associated with the menu; otherwise, WM_HELP is sent to the window that has the keyboard focus. If no window has the keyboard focus, WM_HELP is sent to the currently active window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.USERCHANGED">
            <summary>
            The WM_USERCHANGED message is sent to all windows after the user has logged on or off. When the user logs on or off, the system updates the user-specific settings. The system sends this message immediately after updating the settings.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NOTIFYFORMAT">
            <summary>
            Determines if a window accepts ANSI or Unicode structures in the WM_NOTIFY notification message. WM_NOTIFYFORMAT messages are sent from a common control to its parent window and from the parent window to the common control.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CONTEXTMENU">
            <summary>
            The WM_CONTEXTMENU message notifies a window that the user clicked the right mouse button (right-clicked) in the window.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.STYLECHANGING">
            <summary>
            The WM_STYLECHANGING message is sent to a window when the SetWindowLong function is about to change one or more of the window's styles.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.STYLECHANGED">
            <summary>
            The WM_STYLECHANGED message is sent to a window after the SetWindowLong function has changed one or more of the window's styles
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DISPLAYCHANGE">
            <summary>
            The WM_DISPLAYCHANGE message is sent to all windows when the display resolution has changed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETICON">
            <summary>
            The WM_GETICON message is sent to a window to retrieve a handle to the large or small icon associated with a window. The system displays the large icon in the ALT+TAB dialog, and the small icon in the window caption. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SETICON">
            <summary>
            An application sends the WM_SETICON message to associate a new large or small icon with a window. The system displays the large icon in the ALT+TAB dialog box, and the small icon in the window caption. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCCREATE">
            <summary>
            The WM_NCCREATE message is sent prior to the WM_CREATE message when a window is first created.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCDESTROY">
            <summary>
            The WM_NCDESTROY message informs a window that its nonclient area is being destroyed. The DestroyWindow function sends the WM_NCDESTROY message to the window following the WM_DESTROY message. WM_DESTROY is used to free the allocated memory object associated with the window. 
            The WM_NCDESTROY message is sent after the child windows have been destroyed. In contrast, WM_DESTROY is sent before the child windows are destroyed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCCALCSIZE">
            <summary>
            The WM_NCCALCSIZE message is sent when the size and position of a window's client area must be calculated. By processing this message, an application can control the content of the window's client area when the size or position of the window changes.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCHITTEST">
            <summary>
            The WM_NCHITTEST message is sent to a window when the cursor moves, or when a mouse button is pressed or released. If the mouse is not captured, the message is sent to the window beneath the cursor. Otherwise, the message is sent to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCPAINT">
            <summary>
            The WM_NCPAINT message is sent to a window when its frame must be painted. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCACTIVATE">
            <summary>
            The WM_NCACTIVATE message is sent to a window when its nonclient area needs to be changed to indicate an active or inactive state.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETDLGCODE">
            <summary>
            The WM_GETDLGCODE message is sent to the window procedure associated with a control. By default, the system handles all keyboard input to the control; the system interprets certain types of keyboard input as dialog box navigation keys. To override this default behavior, the control can respond to the WM_GETDLGCODE message to indicate the types of input it wants to process itself.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYNCPAINT">
            <summary>
            The WM_SYNCPAINT message is used to synchronize painting while avoiding linking independent GUI threads.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCMOUSEMOVE">
            <summary>
            The WM_NCMOUSEMOVE message is posted to a window when the cursor is moved within the nonclient area of the window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCLBUTTONDOWN">
            <summary>
            The WM_NCLBUTTONDOWN message is posted when the user presses the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCLBUTTONUP">
            <summary>
            The WM_NCLBUTTONUP message is posted when the user releases the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCLBUTTONDBLCLK">
            <summary>
            The WM_NCLBUTTONDBLCLK message is posted when the user double-clicks the left mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCRBUTTONDOWN">
            <summary>
            The WM_NCRBUTTONDOWN message is posted when the user presses the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCRBUTTONUP">
            <summary>
            The WM_NCRBUTTONUP message is posted when the user releases the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCRBUTTONDBLCLK">
            <summary>
            The WM_NCRBUTTONDBLCLK message is posted when the user double-clicks the right mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCMBUTTONDOWN">
            <summary>
            The WM_NCMBUTTONDOWN message is posted when the user presses the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCMBUTTONUP">
            <summary>
            The WM_NCMBUTTONUP message is posted when the user releases the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCMBUTTONDBLCLK">
            <summary>
            The WM_NCMBUTTONDBLCLK message is posted when the user double-clicks the middle mouse button while the cursor is within the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCXBUTTONDOWN">
            <summary>
            The WM_NCXBUTTONDOWN message is posted when the user presses the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCXBUTTONUP">
            <summary>
            The WM_NCXBUTTONUP message is posted when the user releases the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCXBUTTONDBLCLK">
            <summary>
            The WM_NCXBUTTONDBLCLK message is posted when the user double-clicks the first or second X button while the cursor is in the nonclient area of a window. This message is posted to the window that contains the cursor. If a window has captured the mouse, this message is not posted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INPUT_DEVICE_CHANGE">
            <summary>
            The WM_INPUT_DEVICE_CHANGE message is sent to the window that registered to receive raw input. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INPUT">
            <summary>
            The WM_INPUT message is sent to the window that is getting raw input. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.KEYFIRST">
            <summary>
            This message filters for keyboard messages.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.KEYDOWN">
            <summary>
            The WM_KEYDOWN message is posted to the window with the keyboard focus when a nonsystem key is pressed. A nonsystem key is a key that is pressed when the ALT key is not pressed. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.KEYUP">
            <summary>
            The WM_KEYUP message is posted to the window with the keyboard focus when a nonsystem key is released. A nonsystem key is a key that is pressed when the ALT key is not pressed, or a keyboard key that is pressed when a window has the keyboard focus. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CHAR">
            <summary>
            The WM_CHAR message is posted to the window with the keyboard focus when a WM_KEYDOWN message is translated by the TranslateMessage function. The WM_CHAR message contains the character code of the key that was pressed. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DEADCHAR">
            <summary>
            The WM_DEADCHAR message is posted to the window with the keyboard focus when a WM_KEYUP message is translated by the TranslateMessage function. WM_DEADCHAR specifies a character code generated by a dead key. A dead key is a key that generates a character, such as the umlaut (double-dot), that is combined with another character to form a composite character. For example, the umlaut-O character (Ö) is generated by typing the dead key for the umlaut character, and then typing the O key. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSKEYDOWN">
            <summary>
            The WM_SYSKEYDOWN message is posted to the window with the keyboard focus when the user presses the F10 key (which activates the menu bar) or holds down the ALT key and then presses another key. It also occurs when no window currently has the keyboard focus; in this case, the WM_SYSKEYDOWN message is sent to the active window. The window that receives the message can distinguish between these two contexts by checking the context code in the lParam parameter. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSKEYUP">
            <summary>
            The WM_SYSKEYUP message is posted to the window with the keyboard focus when the user releases a key that was pressed while the ALT key was held down. It also occurs when no window currently has the keyboard focus; in this case, the WM_SYSKEYUP message is sent to the active window. The window that receives the message can distinguish between these two contexts by checking the context code in the lParam parameter. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSCHAR">
            <summary>
            The WM_SYSCHAR message is posted to the window with the keyboard focus when a WM_SYSKEYDOWN message is translated by the TranslateMessage function. It specifies the character code of a system character key — that is, a character key that is pressed while the ALT key is down. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSDEADCHAR">
            <summary>
            The WM_SYSDEADCHAR message is sent to the window with the keyboard focus when a WM_SYSKEYDOWN message is translated by the TranslateMessage function. WM_SYSDEADCHAR specifies the character code of a system dead key — that is, a dead key that is pressed while holding down the ALT key. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.UNICHAR">
            <summary>
            The WM_UNICHAR message is posted to the window with the keyboard focus when a WM_KEYDOWN message is translated by the TranslateMessage function. The WM_UNICHAR message contains the character code of the key that was pressed. 
            The WM_UNICHAR message is equivalent to WM_CHAR, but it uses Unicode Transformation Format (UTF)-32, whereas WM_CHAR uses UTF-16. It is designed to send or post Unicode characters to ANSI windows and it can can handle Unicode Supplementary Plane characters.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.KEYLAST">
            <summary>
            This message filters for keyboard messages.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_STARTCOMPOSITION">
            <summary>
            Sent immediately before the IME generates the composition string as a result of a keystroke. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_ENDCOMPOSITION">
            <summary>
            Sent to an application when the IME ends composition. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_COMPOSITION">
            <summary>
            Sent to an application when the IME changes composition status as a result of a keystroke. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INITDIALOG">
            <summary>
            The WM_INITDIALOG message is sent to the dialog box procedure immediately before a dialog box is displayed. Dialog box procedures typically use this message to initialize controls and carry out any other initialization tasks that affect the appearance of the dialog box. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.COMMAND">
            <summary>
            The WM_COMMAND message is sent when the user selects a command item from a menu, when a control sends a notification message to its parent window, or when an accelerator keystroke is translated. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSCOMMAND">
            <summary>
            A window receives this message when the user chooses a command from the Window menu, clicks the maximize button, minimize button, restore button, close button, or moves the form. You can stop the form from moving by filtering this out.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.TIMER">
            <summary>
            The WM_TIMER message is posted to the installing thread's message queue when a timer expires. The message is posted by the GetMessage or PeekMessage function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.HSCROLL">
            <summary>
            The WM_HSCROLL message is sent to a window when a scroll event occurs in the window's standard horizontal scroll bar. This message is also sent to the owner of a horizontal scroll bar control when a scroll event occurs in the control. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.VSCROLL">
            <summary>
            The WM_VSCROLL message is sent to a window when a scroll event occurs in the window's standard vertical scroll bar. This message is also sent to the owner of a vertical scroll bar control when a scroll event occurs in the control. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INITMENU">
            <summary>
            The WM_INITMENU message is sent when a menu is about to become active. It occurs when the user clicks an item on the menu bar or presses a menu key. This allows the application to modify the menu before it is displayed. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.INITMENUPOPUP">
            <summary>
            The WM_INITMENUPOPUP message is sent when a drop-down menu or submenu is about to become active. This allows an application to modify the menu before it is displayed, without changing the entire menu. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MENUSELECT">
            <summary>
            The WM_MENUSELECT message is sent to a menu's owner window when the user selects a menu item. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MENUCHAR">
            <summary>
            The WM_MENUCHAR message is sent when a menu is active and the user presses a key that does not correspond to any mnemonic or accelerator key. This message is sent to the window that owns the menu. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ENTERIDLE">
            <summary>
            The WM_ENTERIDLE message is sent to the owner window of a modal dialog box or menu that is entering an idle state. A modal dialog box or menu enters an idle state when no messages are waiting in its queue after it has processed one or more previous messages. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MENURBUTTONUP">
            <summary>
            The WM_MENURBUTTONUP message is sent when the user releases the right mouse button while the cursor is on a menu item. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MENUDRAG">
            <summary>
            The WM_MENUDRAG message is sent to the owner of a drag-and-drop menu when the user drags a menu item. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MENUGETOBJECT">
            <summary>
            The WM_MENUGETOBJECT message is sent to the owner of a drag-and-drop menu when the mouse cursor enters a menu item or moves from the center of the item to the top or bottom of the item. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.UNINITMENUPOPUP">
            <summary>
            The WM_UNINITMENUPOPUP message is sent when a drop-down menu or submenu has been destroyed. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MENUCOMMAND">
            <summary>
            The WM_MENUCOMMAND message is sent when the user makes a selection from a menu. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CHANGEUISTATE">
            <summary>
            An application sends the WM_CHANGEUISTATE message to indicate that the user interface (UI) state should be changed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.UPDATEUISTATE">
            <summary>
            An application sends the WM_UPDATEUISTATE message to change the user interface (UI) state for the specified window and all its child windows.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUERYUISTATE">
            <summary>
            An application sends the WM_QUERYUISTATE message to retrieve the user interface (UI) state for a window.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLORMSGBOX">
            <summary>
            The WM_CTLCOLORMSGBOX message is sent to the owner window of a message box before Windows draws the message box. By responding to this message, the owner window can set the text and background colors of the message box by using the given display device context handle. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLOREDIT">
            <summary>
            An edit control that is not read-only or disabled sends the WM_CTLCOLOREDIT message to its parent window when the control is about to be drawn. By responding to this message, the parent window can use the specified device context handle to set the text and background colors of the edit control. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLORLISTBOX">
            <summary>
            Sent to the parent window of a list box before the system draws the list box. By responding to this message, the parent window can set the text and background colors of the list box by using the specified display device context handle. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLORBTN">
            <summary>
            The WM_CTLCOLORBTN message is sent to the parent window of a button before drawing the button. The parent window can change the button's text and background colors. However, only owner-drawn buttons respond to the parent window processing this message. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLORDLG">
            <summary>
            The WM_CTLCOLORDLG message is sent to a dialog box before the system draws the dialog box. By responding to this message, the dialog box can set its text and background colors using the specified display device context handle. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLORSCROLLBAR">
            <summary>
            The WM_CTLCOLORSCROLLBAR message is sent to the parent window of a scroll bar control when the control is about to be drawn. By responding to this message, the parent window can use the display context handle to set the background color of the scroll bar control. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CTLCOLORSTATIC">
            <summary>
            A static control, or an edit control that is read-only or disabled, sends the WM_CTLCOLORSTATIC message to its parent window when the control is about to be drawn. By responding to this message, the parent window can use the specified device context handle to set the text and background colors of the static control. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSEFIRST">
            <summary>
            Use WM_MOUSEFIRST to specify the first mouse message. Use the PeekMessage() Function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSEMOVE">
            <summary>
            The WM_MOUSEMOVE message is posted to a window when the cursor moves. If the mouse is not captured, the message is posted to the window that contains the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.LBUTTONDOWN">
            <summary>
            The WM_LBUTTONDOWN message is posted when the user presses the left mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.LBUTTONUP">
            <summary>
            The WM_LBUTTONUP message is posted when the user releases the left mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.LBUTTONDBLCLK">
            <summary>
            The WM_LBUTTONDBLCLK message is posted when the user double-clicks the left mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.RBUTTONDOWN">
            <summary>
            The WM_RBUTTONDOWN message is posted when the user presses the right mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.RBUTTONUP">
            <summary>
            The WM_RBUTTONUP message is posted when the user releases the right mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.RBUTTONDBLCLK">
            <summary>
            The WM_RBUTTONDBLCLK message is posted when the user double-clicks the right mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MBUTTONDOWN">
            <summary>
            The WM_MBUTTONDOWN message is posted when the user presses the middle mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MBUTTONUP">
            <summary>
            The WM_MBUTTONUP message is posted when the user releases the middle mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MBUTTONDBLCLK">
            <summary>
            The WM_MBUTTONDBLCLK message is posted when the user double-clicks the middle mouse button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSEWHEEL">
            <summary>
            The WM_MOUSEWHEEL message is sent to the focus window when the mouse wheel is rotated. The DefWindowProc function propagates the message to the window's parent. There should be no internal forwarding of the message, since DefWindowProc propagates it up the parent chain until it finds a window that processes it.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.XBUTTONDOWN">
            <summary>
            The WM_XBUTTONDOWN message is posted when the user presses the first or second X button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.XBUTTONUP">
            <summary>
            The WM_XBUTTONUP message is posted when the user releases the first or second X button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.XBUTTONDBLCLK">
            <summary>
            The WM_XBUTTONDBLCLK message is posted when the user double-clicks the first or second X button while the cursor is in the client area of a window. If the mouse is not captured, the message is posted to the window beneath the cursor. Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSEHWHEEL">
            <summary>
            The WM_MOUSEHWHEEL message is sent to the focus window when the mouse's horizontal scroll wheel is tilted or rotated. The DefWindowProc function propagates the message to the window's parent. There should be no internal forwarding of the message, since DefWindowProc propagates it up the parent chain until it finds a window that processes it.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSELAST">
            <summary>
            Use WM_MOUSELAST to specify the last mouse message. Used with PeekMessage() Function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PARENTNOTIFY">
            <summary>
            The WM_PARENTNOTIFY message is sent to the parent of a child window when the child window is created or destroyed, or when the user clicks a mouse button while the cursor is over the child window. When the child window is being created, the system sends WM_PARENTNOTIFY just before the CreateWindow or CreateWindowEx function that creates the window returns. When the child window is being destroyed, the system sends the message before any processing to destroy the window takes place.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ENTERMENULOOP">
            <summary>
            The WM_ENTERMENULOOP message informs an application's main window procedure that a menu modal loop has been entered. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.EXITMENULOOP">
            <summary>
            The WM_EXITMENULOOP message informs an application's main window procedure that a menu modal loop has been exited. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NEXTMENU">
            <summary>
            The WM_NEXTMENU message is sent to an application when the right or left arrow key is used to switch between the menu bar and the system menu. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SIZING">
            <summary>
            The WM_SIZING message is sent to a window that the user is resizing. By processing this message, an application can monitor the size and position of the drag rectangle and, if needed, change its size or position. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CAPTURECHANGED">
            <summary>
            The WM_CAPTURECHANGED message is sent to the window that is losing the mouse capture.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOVING">
            <summary>
            The WM_MOVING message is sent to a window that the user is moving. By processing this message, an application can monitor the position of the drag rectangle and, if needed, change its position.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.POWERBROADCAST">
            <summary>
            Notifies applications that a power-management event has occurred.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DEVICECHANGE">
            <summary>
            Notifies an application of a change to the hardware configuration of a device or the computer.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDICREATE">
            <summary>
            An application sends the WM_MDICREATE message to a multiple-document interface (MDI) client window to create an MDI child window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIDESTROY">
            <summary>
            An application sends the WM_MDIDESTROY message to a multiple-document interface (MDI) client window to close an MDI child window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIACTIVATE">
            <summary>
            An application sends the WM_MDIACTIVATE message to a multiple-document interface (MDI) client window to instruct the client window to activate a different MDI child window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIRESTORE">
            <summary>
            An application sends the WM_MDIRESTORE message to a multiple-document interface (MDI) client window to restore an MDI child window from maximized or minimized size. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDINEXT">
            <summary>
            An application sends the WM_MDINEXT message to a multiple-document interface (MDI) client window to activate the next or previous child window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIMAXIMIZE">
            <summary>
            An application sends the WM_MDIMAXIMIZE message to a multiple-document interface (MDI) client window to maximize an MDI child window. The system resizes the child window to make its client area fill the client window. The system places the child window's window menu icon in the rightmost position of the frame window's menu bar, and places the child window's restore icon in the leftmost position. The system also appends the title bar text of the child window to that of the frame window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDITILE">
            <summary>
            An application sends the WM_MDITILE message to a multiple-document interface (MDI) client window to arrange all of its MDI child windows in a tile format. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDICASCADE">
            <summary>
            An application sends the WM_MDICASCADE message to a multiple-document interface (MDI) client window to arrange all its child windows in a cascade format. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIICONARRANGE">
            <summary>
            An application sends the WM_MDIICONARRANGE message to a multiple-document interface (MDI) client window to arrange all minimized MDI child windows. It does not affect child windows that are not minimized. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIGETACTIVE">
            <summary>
            An application sends the WM_MDIGETACTIVE message to a multiple-document interface (MDI) client window to retrieve the handle to the active MDI child window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDISETMENU">
            <summary>
            An application sends the WM_MDISETMENU message to a multiple-document interface (MDI) client window to replace the entire menu of an MDI frame window, to replace the window menu of the frame window, or both. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ENTERSIZEMOVE">
            <summary>
            The WM_ENTERSIZEMOVE message is sent one time to a window after it enters the moving or sizing modal loop. The window enters the moving or sizing modal loop when the user clicks the window's title bar or sizing border, or when the window passes the WM_SYSCOMMAND message to the DefWindowProc function and the wParam parameter of the message specifies the SC_MOVE or SC_SIZE value. The operation is complete when DefWindowProc returns. 
            The system sends the WM_ENTERSIZEMOVE message regardless of whether the dragging of full windows is enabled.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.EXITSIZEMOVE">
            <summary>
            The WM_EXITSIZEMOVE message is sent one time to a window, after it has exited the moving or sizing modal loop. The window enters the moving or sizing modal loop when the user clicks the window's title bar or sizing border, or when the window passes the WM_SYSCOMMAND message to the DefWindowProc function and the wParam parameter of the message specifies the SC_MOVE or SC_SIZE value. The operation is complete when DefWindowProc returns. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DROPFILES">
            <summary>
            Sent when the user drops a file on the window of an application that has registered itself as a recipient of dropped files.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MDIREFRESHMENU">
            <summary>
            An application sends the WM_MDIREFRESHMENU message to a multiple-document interface (MDI) client window to refresh the window menu of the MDI frame window. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_SETCONTEXT">
            <summary>
            Sent to an application when a window is activated. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_NOTIFY">
            <summary>
            Sent to an application to notify it of changes to the IME window. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_CONTROL">
            <summary>
            Sent by an application to direct the IME window to carry out the requested command. The application uses this message to control the IME window that it has created. To send this message, the application calls the SendMessage function with the following parameters.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_COMPOSITIONFULL">
            <summary>
            Sent to an application when the IME window finds no space to extend the area for the composition window. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_SELECT">
            <summary>
            Sent to an application when the operating system is about to change the current IME. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_CHAR">
            <summary>
            Sent to an application when the IME gets a character of the conversion result. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_REQUEST">
            <summary>
            Sent to an application to provide commands and request information. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_KEYDOWN">
            <summary>
            Sent to an application by the IME to notify the application of a key press and to keep message order. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.IME_KEYUP">
            <summary>
            Sent to an application by the IME to notify the application of a key release and to keep message order. A window receives this message through its WindowProc function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSEHOVER">
            <summary>
            The WM_MOUSEHOVER message is posted to a window when the cursor hovers over the client area of the window for the period of time specified in a prior call to TrackMouseEvent.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.MOUSELEAVE">
            <summary>
            The WM_MOUSELEAVE message is posted to a window when the cursor leaves the client area of the window specified in a prior call to TrackMouseEvent.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCMOUSEHOVER">
            <summary>
            The WM_NCMOUSEHOVER message is posted to a window when the cursor hovers over the nonclient area of the window for the period of time specified in a prior call to TrackMouseEvent.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.NCMOUSELEAVE">
            <summary>
            The WM_NCMOUSELEAVE message is posted to a window when the cursor leaves the nonclient area of the window specified in a prior call to TrackMouseEvent.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.WTSSESSION_CHANGE">
            <summary>
            The WM_WTSSESSION_CHANGE message notifies applications of changes in session state.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CUT">
            <summary>
            An application sends a WM_CUT message to an edit control or combo box to delete (cut) the current selection, if any, in the edit control and copy the deleted text to the clipboard in CF_TEXT format. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.COPY">
            <summary>
            An application sends the WM_COPY message to an edit control or combo box to copy the current selection to the clipboard in CF_TEXT format. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PASTE">
            <summary>
            An application sends a WM_PASTE message to an edit control or combo box to copy the current content of the clipboard to the edit control at the current caret position. Data is inserted only if the clipboard contains data in CF_TEXT format. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CLEAR">
            <summary>
            An application sends a WM_CLEAR message to an edit control or combo box to delete (clear) the current selection, if any, from the edit control. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.UNDO">
            <summary>
            An application sends a WM_UNDO message to an edit control to undo the last operation. When this message is sent to an edit control, the previously deleted text is restored or the previously added text is deleted.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.RENDERFORMAT">
            <summary>
            The WM_RENDERFORMAT message is sent to the clipboard owner if it has delayed rendering a specific clipboard format and if an application has requested data in that format. The clipboard owner must render data in the specified format and place it on the clipboard by calling the SetClipboardData function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.RENDERALLFORMATS">
            <summary>
            The WM_RENDERALLFORMATS message is sent to the clipboard owner before it is destroyed, if the clipboard owner has delayed rendering one or more clipboard formats. For the content of the clipboard to remain available to other applications, the clipboard owner must render data in all the formats it is capable of generating, and place the data on the clipboard by calling the SetClipboardData function. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DESTROYCLIPBOARD">
            <summary>
            The WM_DESTROYCLIPBOARD message is sent to the clipboard owner when a call to the EmptyClipboard function empties the clipboard. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DRAWCLIPBOARD">
            <summary>
            The WM_DRAWCLIPBOARD message is sent to the first window in the clipboard viewer chain when the content of the clipboard changes. This enables a clipboard viewer window to display the new content of the clipboard. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PAINTCLIPBOARD">
            <summary>
            The WM_PAINTCLIPBOARD message is sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF_OWNERDISPLAY format and the clipboard viewer's client area needs repainting. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.VSCROLLCLIPBOARD">
            <summary>
            The WM_VSCROLLCLIPBOARD message is sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF_OWNERDISPLAY format and an event occurs in the clipboard viewer's vertical scroll bar. The owner should scroll the clipboard image and update the scroll bar values. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SIZECLIPBOARD">
            <summary>
            The WM_SIZECLIPBOARD message is sent to the clipboard owner by a clipboard viewer window when the clipboard contains data in the CF_OWNERDISPLAY format and the clipboard viewer's client area has changed size. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.ASKCBFORMATNAME">
            <summary>
            The WM_ASKCBFORMATNAME message is sent to the clipboard owner by a clipboard viewer window to request the name of a CF_OWNERDISPLAY clipboard format.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CHANGECBCHAIN">
            <summary>
            The WM_CHANGECBCHAIN message is sent to the first window in the clipboard viewer chain when a window is being removed from the chain. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.HSCROLLCLIPBOARD">
            <summary>
            The WM_HSCROLLCLIPBOARD message is sent to the clipboard owner by a clipboard viewer window. This occurs when the clipboard contains data in the CF_OWNERDISPLAY format and an event occurs in the clipboard viewer's horizontal scroll bar. The owner should scroll the clipboard image and update the scroll bar values. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.QUERYNEWPALETTE">
            <summary>
            This message informs a window that it is about to receive the keyboard focus, giving the window the opportunity to realize its logical palette when it receives the focus. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PALETTEISCHANGING">
            <summary>
            The WM_PALETTEISCHANGING message informs applications that an application is going to realize its logical palette. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PALETTECHANGED">
            <summary>
            This message is sent by the OS to all top-level and overlapped windows after the window with the keyboard focus realizes its logical palette. 
            This message enables windows that do not have the keyboard focus to realize their logical palettes and update their client areas.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.HOTKEY">
            <summary>
            The WM_HOTKEY message is posted when the user presses a hot key registered by the RegisterHotKey function. The message is placed at the top of the message queue associated with the thread that registered the hot key. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PRINT">
            <summary>
            The WM_PRINT message is sent to a window to request that it draw itself in the specified device context, most commonly in a printer device context.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.PRINTCLIENT">
            <summary>
            The WM_PRINTCLIENT message is sent to a window to request that it draw its client area in the specified device context, most commonly in a printer device context.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.APPCOMMAND">
            <summary>
            The WM_APPCOMMAND message notifies a window that the user generated an application command event, for example, by clicking an application command button using the mouse or typing an application command key on the keyboard.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.THEMECHANGED">
            <summary>
            The WM_THEMECHANGED message is broadcast to every window following a theme change event. Examples of theme change events are the activation of a theme, the deactivation of a theme, or a transition from one theme to another.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CLIPBOARDUPDATE">
            <summary>
            Sent when the contents of the clipboard have changed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DWMCOMPOSITIONCHANGED">
            <summary>
            The system will send a window the WM_DWMCOMPOSITIONCHANGED message to indicate that the availability of desktop composition has changed.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DWMNCRENDERINGCHANGED">
            <summary>
            WM_DWMNCRENDERINGCHANGED is called when the non-client area rendering status of a window has changed. Only windows that have set the flag DWM_BLURBEHIND.fTransitionOnMaximized to true will get this message. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DWMCOLORIZATIONCOLORCHANGED">
            <summary>
            Sent to all top-level windows when the colorization color has changed. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.DWMWINDOWMAXIMIZEDCHANGE">
            <summary>
            WM_DWMWINDOWMAXIMIZEDCHANGE will let you know when a DWM composed window is maximized. You also have to register for this message as well. You'd have other windowd go opaque when this message is sent.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.GETTITLEBARINFOEX">
            <summary>
            Sent to request extended title bar information. A window receives this message through its WindowProc function.
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.APP">
            <summary>
            The WM_APP constant is used by applications to help define private messages, usually of the form WM_APP+X, where X is an integer value. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.USER">
            <summary>
            The WM_USER constant is used by applications to help define private messages for use by private window classes, usually of the form WM_USER+X, where X is an integer value. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CPL_LAUNCH">
            <summary>
            An application sends the WM_CPL_LAUNCH message to Windows Control Panel to request that a Control Panel application be started. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.CPL_LAUNCHED">
            <summary>
            The WM_CPL_LAUNCHED message is sent when a Control Panel application, started by the WM_CPL_LAUNCH message, has closed. The WM_CPL_LAUNCHED message is sent to the window identified by the wParam parameter of the WM_CPL_LAUNCH message that started the application. 
            </summary>
        </member>
        <member name="F:VRage.Win32.WinApi.WM.SYSTIMER">
            <summary>
            WM_SYSTIMER is a well-known yet still undocumented message. Windows uses WM_SYSTIMER for internal actions like scrolling.
            </summary>
        </member>
    </members>
</doc>
