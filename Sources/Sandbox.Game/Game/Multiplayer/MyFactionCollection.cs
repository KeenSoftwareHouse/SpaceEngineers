using ProtoBuf;
using Sandbox.Common;
using Sandbox.Common.ObjectBuilders;
using Sandbox.Common.ObjectBuilders.Definitions;
using Sandbox.Engine.Multiplayer;
using Sandbox.Game.Entities;
using Sandbox.Game.World;
using SteamSDK;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using VRage.Serialization;
using Sandbox.ModAPI;
using Sandbox.Engine.Networking;

namespace Sandbox.Game.Multiplayer
{
    [PreloadRequired]
    public partial class MyFactionCollection :IEnumerable<KeyValuePair<long, MyFaction>>
    {
        public enum MyFactionPeaceRequestState
        {
            None,
            Pending,
            Sent
        }

        public enum MyFactionStateChange
        {
            RemoveFaction,
            SendPeaceRequest,
            CancelPeaceRequest,
            AcceptPeace,
            DeclareWar,

            FactionMemberSendJoin,
            FactionMemberCancelJoin,
            FactionMemberAcceptJoin,
            FactionMemberKick,
            FactionMemberPromote,
            FactionMemberDemote,
            FactionMemberLeave
        }

        private struct MyFactionPair
        {
            public long FactionId1;
            public long FactionId2;

            public MyFactionPair(long id1, long id2)
            {
                FactionId1 = id1;
                FactionId2 = id2;
            }

            #region Comparer

            public class ComparerType : IEqualityComparer<MyFactionPair>
            {
                public bool Equals(MyFactionPair x, MyFactionPair y)
                {
                    return ((x.FactionId1 == y.FactionId1 && x.FactionId2 == y.FactionId2) ||
                            (x.FactionId1 == y.FactionId2 && x.FactionId2 == y.FactionId1));
                }

                public int GetHashCode(MyFactionPair obj)
                {
                    return obj.FactionId1.GetHashCode() ^ obj.FactionId2.GetHashCode();
                }
            }

            public static readonly ComparerType Comparer = new ComparerType();

            #endregion
        }

        [MessageIdAttribute(3298, P2PMessageEnum.Reliable)]
        [ProtoContract]
        struct AddFactionMsg
        {
            [ProtoMember]
            public long FounderId;
            /// <summary>
            /// Do not use this for request, this value is always generated by server!
            /// </summary>
            [ProtoMember]
            public long FactionId;
            [ProtoMember]
            public string FactionTag;
            [ProtoMember]
            public string FactionName;
            [ProtoMember]
            public string FactionDescription;
            [ProtoMember]
            public string FactionPrivateInfo;
        }

        [MessageIdAttribute(3300, P2PMessageEnum.Reliable)]
        [ProtoContract]
        struct EditFactionMsg
        {
            [ProtoMember]
            public long FactionId;
            [ProtoMember]
            public string FactionTag;
            [ProtoMember]
            public string FactionName;
            [ProtoMember]
            public string FactionDescription;
            [ProtoMember]
            public string FactionPrivateInfo;
        }

        [MessageIdAttribute(3299, P2PMessageEnum.Reliable)]
        struct FactionStateChangeMsg
        {
            public MyFactionStateChange Action;
            public long FromFactionId;
            public long ToFactionId;
            public long PlayerId;
            public long SenderId;
        }

        [MessageIdAttribute(3301, P2PMessageEnum.Reliable)]
        struct ChangeAutoAcceptMsg
        {
            public long     FactionId;
            public long     PlayerId;
            public BoolBlit AutoAcceptMember;
            public BoolBlit AutoAcceptPeace;
        }

        [MessageId(3321, P2PMessageEnum.Reliable)]
        [ProtoContract]
        struct AllFactionsRequestMsg
        {
            [ProtoMember]
            public ulong ClientSteamId;
            [ProtoMember]
            public int PlayerSerialId;
        }

        [MessageId(3322, P2PMessageEnum.Reliable)]
        [ProtoContract]
        struct AllFactionsSuccessMsg
        {
            [ProtoMember]
            public List<MyObjectBuilder_Faction> Factions;
        }


        /// <summary>
        /// All factions in a game.
        /// </summary>
        private Dictionary<long, MyFaction> m_factions = new Dictionary<long, MyFaction>();
        /// <summary>
        /// 
        /// </summary>
        private Dictionary<long, HashSet<long>> m_factionRequests = new Dictionary<long, HashSet<long>>();
        /// <summary>
        /// Relations between factions.
        /// </summary>
        private Dictionary<MyFactionPair, MyRelationsBetweenFactions> m_relationsBetweenFactions = new Dictionary<MyFactionPair, MyRelationsBetweenFactions>(MyFactionPair.Comparer);
        /// <summary>
        /// Player in faction dictionary.
        /// </summary>
        private Dictionary<long, long> m_playerFaction = new Dictionary<long, long>();

        static MyFactionCollection()
        {
            MySyncLayer.RegisterMessage<AddFactionMsg>(CreateFactionRequest, MyMessagePermissions.ToServer, MyTransportMessageEnum.Request);
            MySyncLayer.RegisterMessage<AddFactionMsg>(CreateFactionSuccess, MyMessagePermissions.FromServer, MyTransportMessageEnum.Success);

            MySyncLayer.RegisterMessage<EditFactionMsg>(EditFactionRequest, MyMessagePermissions.ToServer, MyTransportMessageEnum.Request);
            MySyncLayer.RegisterMessage<EditFactionMsg>(EditFactionSuccess, MyMessagePermissions.FromServer, MyTransportMessageEnum.Success);

            MySyncLayer.RegisterMessage<FactionStateChangeMsg>(FactionStateChangeRequest, MyMessagePermissions.ToServer, MyTransportMessageEnum.Request);
            MySyncLayer.RegisterMessage<FactionStateChangeMsg>(FactionStateChangeSuccess, MyMessagePermissions.FromServer, MyTransportMessageEnum.Success);

            MySyncLayer.RegisterMessage<ChangeAutoAcceptMsg>(ChangeAutoAcceptRequest, MyMessagePermissions.ToServer, MyTransportMessageEnum.Request);
            MySyncLayer.RegisterMessage<ChangeAutoAcceptMsg>(ChangeAutoAcceptSuccess, MyMessagePermissions.FromServer, MyTransportMessageEnum.Success);

            MySyncLayer.RegisterMessage<AllFactionsRequestMsg>(OnAllFactionsRequest, MyMessagePermissions.ToServer, MyTransportMessageEnum.Request);
            MySyncLayer.RegisterMessage<AllFactionsSuccessMsg>(OnAllFactionsSuccess, MyMessagePermissions.FromServer, MyTransportMessageEnum.Success);
        }

        public bool FactionTagExists(string tag, IMyFaction doNotCheck = null)
        {
            foreach (var entry in m_factions)
            {
                var faction = entry.Value;

                if (doNotCheck != null && doNotCheck.FactionId == faction.FactionId)
                    continue;

                if (string.Equals(tag, faction.Tag, StringComparison.OrdinalIgnoreCase))
                    return true;
            }
            return false;
        }

        public bool FactionNameExists(string name, IMyFaction doNotCheck = null)
        {
            foreach (var entry in m_factions)
            {
                var faction = entry.Value;

                if (doNotCheck != null && doNotCheck.FactionId == faction.FactionId)
                    continue;

                if (string.Equals(name, faction.Name, StringComparison.OrdinalIgnoreCase))
                    return true;
            }
            return false;
        }

        public IMyFaction TryGetFactionById(long factionId)
        {
            MyFaction faction;
            if (m_factions.TryGetValue(factionId, out faction))
                return faction;
            return null;
        }

        public IMyFaction TryGetPlayerFaction(long playerId)
        {
            if (m_playerFaction.ContainsKey(playerId) && m_factions.ContainsKey(m_playerFaction[playerId]))
                return m_factions[m_playerFaction[playerId]];

            return null;
        }

        public MyFaction GetPlayerFaction(long playerId)
        {
            if (m_playerFaction.ContainsKey(playerId) && m_factions.ContainsKey(m_playerFaction[playerId]))
                return m_factions[m_playerFaction[playerId]];

            return null;
        }

        public void AddPlayerToFaction(long playerId, long factionId)
        {
            m_playerFaction[playerId] = factionId;
        }

        public void KickPlayerFromFaction(long playerId)
        {
            m_playerFaction.Remove(playerId);
        }

        /// <summary>
        /// Use this for quick check of relation between two factions.
        /// </summary>
        /// <param name="factionId1">First faction id</param>
        /// <param name="factionId2">Second faction id</param>
        /// <returns>Enum that describes the relation between given factions</returns>
        public MyRelationsBetweenFactions GetRelationBetweenFactions(long factionId1, long factionId2)
        {
            if (factionId1 == factionId2 && factionId1 != 0)
                return MyRelationsBetweenFactions.Neutral;

            var key = new MyFactionPair(factionId1, factionId2);

            if (m_relationsBetweenFactions.ContainsKey(key))
                return m_relationsBetweenFactions[key];

            return MyRelationsBetweenFactions.Enemies;
        }

        public bool AreFactionsEnemies(long factionId1, long factionId2)
        {
            return GetRelationBetweenFactions(factionId1, factionId2) == MyRelationsBetweenFactions.Enemies;
        }

        public MyFactionPeaceRequestState GetRequestState(long myFactionId, long foreignFactionId)
        {
            if (m_factionRequests.ContainsKey(myFactionId) && m_factionRequests[myFactionId].Contains(foreignFactionId))
                return MyFactionPeaceRequestState.Sent;

            if (m_factionRequests.ContainsKey(foreignFactionId) && m_factionRequests[foreignFactionId].Contains(myFactionId))
                return MyFactionPeaceRequestState.Pending;

            return MyFactionPeaceRequestState.None;
        }

        public bool IsPeaceRequestStateSent(long myFactionId, long foreignFactionId)
        {
            return GetRequestState(myFactionId, foreignFactionId) == MyFactionPeaceRequestState.Sent;
        }

        public bool IsPeaceRequestStatePending(long myFactionId, long foreignFactionId)
        {
            return GetRequestState(myFactionId, foreignFactionId) == MyFactionPeaceRequestState.Pending;
        }


        public event Action<MyFactionStateChange, long, long, long, long> FactionStateChanged;

        public void RemoveFaction(long factionId)
        {
            SendFactionChange(MyFactionStateChange.RemoveFaction, factionId, factionId, 0);
        }

        public void SendPeaceRequest(long fromFactionId, long toFactionId)
        {
            SendFactionChange(MyFactionStateChange.SendPeaceRequest, fromFactionId, toFactionId, 0);
        }

        public void CancelPeaceRequest(long fromFactionId, long toFactionId)
        {
            SendFactionChange(MyFactionStateChange.CancelPeaceRequest, fromFactionId, toFactionId, 0);
        }

        public void AcceptPeace(long fromFactionId, long toFactionId)
        {
            SendFactionChange(MyFactionStateChange.AcceptPeace, fromFactionId, toFactionId, 0);
        }

        public void DeclareWar(long fromFactionId, long toFactionId)
        {
            SendFactionChange(MyFactionStateChange.DeclareWar, fromFactionId, toFactionId, 0);
        }

        public void SendJoinRequest(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberSendJoin, factionId, factionId, playerId);
        }

        public void CancelJoinRequest(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberCancelJoin, factionId, factionId, playerId);
        }

        public void AcceptJoin(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberAcceptJoin, factionId, factionId, playerId);
        }

        public void KickMember(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberKick, factionId, factionId, playerId);
        }

        public void PromoteMember(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberPromote, factionId, factionId, playerId);
        }

        public void DemoteMember(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberDemote, factionId, factionId, playerId);
        }

        public void MemberLeaves(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberLeave, factionId, factionId, playerId);
        }

        bool CheckFactionStateChange(MyFactionStateChange action, long fromFactionId, long toFactionId, long playerId, long senderId)
        {
            Debug.Assert(Sync.IsServer, "Only server can check state of message!");
            if (!Sync.IsServer)
                return false;

            if (!m_factions.ContainsKey(fromFactionId) || !m_factions.ContainsKey(toFactionId))
                return false;

            var key = new MyFactionPair(fromFactionId, toFactionId);
            HashSet<long> tmpSet;
            MyRelationsBetweenFactions tmp;

            switch (action)
            {
                case MyFactionStateChange.RemoveFaction: return true;

                case MyFactionStateChange.SendPeaceRequest:   return (m_factionRequests.TryGetValue(fromFactionId, out tmpSet)) ? !tmpSet.Contains(toFactionId) : true;
                case MyFactionStateChange.CancelPeaceRequest: return (m_factionRequests.TryGetValue(fromFactionId, out tmpSet)) ?  tmpSet.Contains(toFactionId) : false;

                case MyFactionStateChange.AcceptPeace: return (m_relationsBetweenFactions.TryGetValue(key, out tmp)) ? tmp != MyRelationsBetweenFactions.Neutral : true;
                case MyFactionStateChange.DeclareWar:  return (m_relationsBetweenFactions.TryGetValue(key, out tmp)) ? tmp != MyRelationsBetweenFactions.Enemies : false;

                case MyFactionStateChange.FactionMemberSendJoin:   return !m_factions[fromFactionId].IsMember(playerId)  && !m_factions[fromFactionId].JoinRequests.ContainsKey(playerId);
                case MyFactionStateChange.FactionMemberCancelJoin: return !m_factions[fromFactionId].IsMember(playerId)  &&  m_factions[fromFactionId].JoinRequests.ContainsKey(playerId);
                case MyFactionStateChange.FactionMemberAcceptJoin: return  m_factions[fromFactionId].JoinRequests.ContainsKey(playerId);
                case MyFactionStateChange.FactionMemberKick:       return  m_factions[fromFactionId].IsMember(playerId);
                case MyFactionStateChange.FactionMemberPromote:    return  m_factions[fromFactionId].IsMember(playerId);
                case MyFactionStateChange.FactionMemberDemote:     return  m_factions[fromFactionId].IsLeader(playerId);
                case MyFactionStateChange.FactionMemberLeave:      return  m_factions[fromFactionId].IsMember(playerId);
            }
            return false;
        }

        void ApplyFactionStateChange(MyFactionStateChange action, long fromFactionId, long toFactionId, long playerId, long senderId)
        {
            switch (action)
            {
                case MyFactionStateChange.RemoveFaction:
                    if (m_factions[fromFactionId].IsMember(MySession.LocalPlayerId)) // kick all players from faction
                        m_playerFaction.Remove(playerId);

                    foreach (var faction in m_factions)
                    {
                        if (faction.Key != fromFactionId) // remove faction from neutrals and requests
                        {
                            ClearRequest(fromFactionId, faction.Key);
                            RemoveRelation(fromFactionId, faction.Key);
                        }
                    }
                    m_factions.Remove(fromFactionId);
                    break;

                case MyFactionStateChange.SendPeaceRequest:
                    HashSet<long> tmp;

                    if (m_factionRequests.TryGetValue(fromFactionId, out tmp))
                        tmp.Add(toFactionId);
                    else
                    {
                        tmp = new HashSet<long>();
                        tmp.Add(toFactionId);
                        m_factionRequests.Add(fromFactionId, tmp);
                    }
                    break;

                case MyFactionStateChange.CancelPeaceRequest:
                    ClearRequest(fromFactionId, toFactionId);
                    break;

                case MyFactionStateChange.AcceptPeace:
                    ClearRequest(fromFactionId, toFactionId);
                    ChangeRelation(fromFactionId, toFactionId, MyRelationsBetweenFactions.Neutral);
                    break;

                case MyFactionStateChange.DeclareWar:
                    ClearRequest(fromFactionId, toFactionId);
                    ChangeRelation(fromFactionId, toFactionId, MyRelationsBetweenFactions.Enemies);
                    break;

                case MyFactionStateChange.FactionMemberSendJoin:   m_factions[fromFactionId].AddJoinRequest(playerId); break;
                case MyFactionStateChange.FactionMemberCancelJoin: m_factions[fromFactionId].CancelJoinRequest(playerId); break;
                case MyFactionStateChange.FactionMemberAcceptJoin: m_factions[fromFactionId].AcceptJoin(playerId); break;
                case MyFactionStateChange.FactionMemberLeave:
                case MyFactionStateChange.FactionMemberKick:    m_factions[fromFactionId].KickMember(playerId); break;
                case MyFactionStateChange.FactionMemberPromote: m_factions[fromFactionId].PromoteMember(playerId); break;
                case MyFactionStateChange.FactionMemberDemote:  m_factions[fromFactionId].DemoteMember(playerId); break;
            }
        }

        void ClearRequest(long fromFactionId, long toFactionId)
        {
            if (m_factionRequests.ContainsKey(fromFactionId))
                m_factionRequests[fromFactionId].Remove(toFactionId);

            if (m_factionRequests.ContainsKey(toFactionId))
                m_factionRequests[toFactionId].Remove(fromFactionId);
        }

        void ChangeRelation(long fromFactionId, long toFactionId, MyRelationsBetweenFactions relation)
        {
            m_relationsBetweenFactions[new MyFactionPair(fromFactionId, toFactionId)] = relation;
        }

        void RemoveRelation(long fromFactionId, long toFactionId)
        {
            m_relationsBetweenFactions.Remove(new MyFactionPair(fromFactionId, toFactionId));
        }

        void SendFactionChange(MyFactionStateChange action, long fromFactionId, long toFactionId, long playerId)
        {
            var msg = new FactionStateChangeMsg();
            msg.Action = action;
            msg.FromFactionId = fromFactionId;
            msg.ToFactionId = toFactionId;
            msg.PlayerId = playerId;
            msg.SenderId = MySession.LocalPlayerId;
            Sync.Layer.SendMessageToServer(ref msg, MyTransportMessageEnum.Request);
        }

        static void FactionStateChangeRequest(ref FactionStateChangeMsg msg, MyNetworkClient sender)
        {
            var fromFaction = MySession.Static.Factions.TryGetFactionById(msg.FromFactionId);
            var toFaction   = MySession.Static.Factions.TryGetFactionById(msg.ToFactionId);

            if (fromFaction != null && toFaction != null &&
                MySession.Static.Factions.CheckFactionStateChange(msg.Action, msg.FromFactionId, msg.ToFactionId, msg.PlayerId, msg.SenderId))
            {
                if ((msg.Action == MyFactionStateChange.FactionMemberKick ||
                     msg.Action == MyFactionStateChange.FactionMemberLeave) && fromFaction.Members.Count() == 1)
                {
                    msg.Action = MyFactionStateChange.RemoveFaction;
                }
                else if (msg.Action == MyFactionStateChange.FactionMemberSendJoin && toFaction.AutoAcceptMember)
                { 
                    msg.Action = MyFactionStateChange.FactionMemberAcceptJoin;
                    msg.SenderId = 0; // no need to check who accepted this
                }
                else if (msg.Action == MyFactionStateChange.SendPeaceRequest && toFaction.AutoAcceptPeace)
                {
                    msg.Action = MyFactionStateChange.AcceptPeace;
                    msg.SenderId = 0; // no need to check who accepted this
                }

                Sync.Layer.SendMessageToAllAndSelf(ref msg, MyTransportMessageEnum.Success);
            }
            /*else
            {
                Sync.Layer.SendMessage(ref msg, SteamSDK.sender.SteamUserId, MyTransportMessageEnum.Failure);
            }*/
        }

        static void FactionStateChangeSuccess(ref FactionStateChangeMsg msg, MyNetworkClient sender)
        {
            var fromFaction = MySession.Static.Factions.TryGetFactionById(msg.FromFactionId);
            var toFaction   = MySession.Static.Factions.TryGetFactionById(msg.ToFactionId);

            if (fromFaction != null && toFaction != null)
            {
                MySession.Static.Factions.ApplyFactionStateChange(msg.Action, msg.FromFactionId, msg.ToFactionId, msg.PlayerId, msg.SenderId);

                var handler = MySession.Static.Factions.FactionStateChanged;

                if (handler != null)
                    handler(msg.Action, msg.FromFactionId, msg.ToFactionId, msg.PlayerId, msg.SenderId);
            }
        }

        public void RequestAllFactions()
        {
            var msg = new AllFactionsRequestMsg();
            msg.ClientSteamId = MySteam.UserId;
            msg.PlayerSerialId = 0;

            Sync.Layer.SendMessageToServer(ref msg);
        }

        static void OnAllFactionsRequest(ref AllFactionsRequestMsg msg, MyNetworkClient sender)
        {
            var response = new AllFactionsSuccessMsg();
            response.Factions = MySession.Static.Factions.SaveFactions();

            Sync.Layer.SendMessage(ref response, sender.SteamUserId, messageType: MyTransportMessageEnum.Success);
        }

        static void OnAllFactionsSuccess(ref AllFactionsSuccessMsg msg, MyNetworkClient sender)
        {
            MySession.Static.Factions.LoadFactions(msg.Factions);
        }

        private List<MyObjectBuilder_Faction> SaveFactions()
        {
            List<MyObjectBuilder_Faction> factionBuilders = new List<MyObjectBuilder_Faction>();
            foreach (var factionPair in m_factions)
            {
                MyObjectBuilder_Faction ob = factionPair.Value.GetObjectBuilder();
                factionBuilders.Add(ob);
            }

            return factionBuilders;
        }

        private void LoadFactions(List<MyObjectBuilder_Faction> factionBuilders)
        {
            foreach (var builder in factionBuilders) 
            {
                if (m_factions.ContainsKey(builder.FactionId))
                    continue;

                var faction = new MyFaction(builder);
                Add(faction);

                // Must initialize also m_playerFaction
                foreach (var member in faction.Members)
                {
                    AddPlayerToFaction(member.Value.PlayerId, faction.FactionId);
                }
            }
        }


        #region Change Faction AutoAccept

        public event Action<long, bool, bool> FactionAutoAcceptChanged;

        public void ChangeAutoAccept(long factionId, long playerId, bool autoAcceptMember, bool autoAcceptPeace)
        {
            SendChangeAutoAccept(factionId, playerId, autoAcceptMember, autoAcceptPeace);
        }

        void SendChangeAutoAccept(long factionId, long playerId, bool autoAcceptMember, bool autoAcceptPeace)
        {
            var msg        = new ChangeAutoAcceptMsg();
            msg.FactionId  = factionId;
            msg.PlayerId   = playerId;
            msg.AutoAcceptMember = autoAcceptMember;
            msg.AutoAcceptPeace  = autoAcceptPeace;
            Sync.Layer.SendMessageToServer(ref msg, MyTransportMessageEnum.Request);
        }

        static void ChangeAutoAcceptRequest(ref ChangeAutoAcceptMsg msg, MyNetworkClient sender)
        {
            var faction = MySession.Static.Factions.TryGetFactionById(msg.FactionId);

            if (faction != null && faction.IsLeader(msg.PlayerId))
            {
                Sync.Layer.SendMessageToAllAndSelf(ref msg, MyTransportMessageEnum.Success);
            }
        }

        static void ChangeAutoAcceptSuccess(ref ChangeAutoAcceptMsg msg, MyNetworkClient sender)
        {
            MySession.Static.Factions[msg.FactionId].AutoAcceptMember = msg.AutoAcceptMember;
            MySession.Static.Factions[msg.FactionId].AutoAcceptPeace  = msg.AutoAcceptPeace;

            var handler = MySession.Static.Factions.FactionAutoAcceptChanged;

            if (handler != null)
                handler(msg.FactionId, msg.AutoAcceptMember, msg.AutoAcceptPeace);
        }

        #endregion

        #region Edit Faction

        public event Action<long> FactionEdited;

        public void EditFaction(long factionId, string tag, string name, string desc, string privateInfo)
        {
            SendEditFaction(factionId, tag, name, desc, privateInfo);
        }

        void SendEditFaction(long factionId, string factionTag, string factionName, string factionDesc, string factionPrivate)
        {
            var msg                = new EditFactionMsg();
            msg.FactionId          = factionId;
            msg.FactionTag         = factionTag;
            msg.FactionName        = factionName;
            msg.FactionDescription = factionDesc;
            msg.FactionPrivateInfo = factionPrivate;
            Sync.Layer.SendMessageToServer(ref msg, MyTransportMessageEnum.Request);
        }

        static void EditFactionRequest(ref EditFactionMsg msg, MyNetworkClient sender)
        {
            var faction = MySession.Static.Factions.TryGetFactionById(msg.FactionId);

            if (faction != null && !MySession.Static.Factions.FactionTagExists(msg.FactionTag, faction) && !MySession.Static.Factions.FactionNameExists(msg.FactionName, faction))
            {
                Sync.Layer.SendMessageToAllAndSelf(ref msg, MyTransportMessageEnum.Success);
            }
            /*else
            {
                Sync.Layer.SendMessage(ref msg, SteamSDK.sender.SteamUserId, MyTransportMessageEnum.Failure);
            }*/
        }

        static void EditFactionSuccess(ref EditFactionMsg msg, MyNetworkClient sender)
        {
            MySession.Static.Factions[msg.FactionId].Tag         = msg.FactionTag;
            MySession.Static.Factions[msg.FactionId].Name        = msg.FactionName;
            MySession.Static.Factions[msg.FactionId].Description = msg.FactionDescription;
            MySession.Static.Factions[msg.FactionId].PrivateInfo = msg.FactionPrivateInfo;

            var handler = MySession.Static.Factions.FactionEdited;

            if (handler != null)
                handler(msg.FactionId);
        }

        #endregion

        #region Create Faction

        public event Action<long> FactionCreated;

        public void CreateFaction(long founderId, string tag, string name, string desc, string privateInfo)
        {
            SendCreateFaction(founderId, tag, name, desc, privateInfo);
        }

        void Add(MyFaction faction)
        {
            m_factions.Add(faction.FactionId, faction);
        }

        void SendCreateFaction(long founderId, string factionTag, string factionName, string factionDesc, string factionPrivate)
        {
            var msg                = new AddFactionMsg();
            msg.FounderId          = founderId;
            msg.FactionTag         = factionTag;
            msg.FactionName        = factionName;
            msg.FactionDescription = factionDesc;
            msg.FactionPrivateInfo = factionPrivate;
            Sync.Layer.SendMessageToServer(ref msg, MyTransportMessageEnum.Request);
        }

        static void CreateFactionRequest(ref AddFactionMsg msg, MyNetworkClient sender)
        {
            msg.FactionId = MyEntityIdentifier.AllocateId(MyEntityIdentifier.ID_OBJECT_TYPE.FACTION);
            var faction   = MySession.Static.Factions.TryGetFactionById(msg.FactionId);
            var senderFaction = MySession.Static.Factions.TryGetPlayerFaction(msg.FounderId);

            if (senderFaction == null && faction == null 
                && !MySession.Static.Factions.FactionTagExists(msg.FactionTag)
                && !MySession.Static.Factions.FactionNameExists(msg.FactionName)
                && Sync.Players.HasIdentity(msg.FounderId))
            {
                Sync.Layer.SendMessageToAllAndSelf(ref msg, MyTransportMessageEnum.Success);
            }
            /*else
            {
                Sync.Layer.SendMessage(ref msg, SteamSDK.sender.SteamUserId, MyTransportMessageEnum.Failure);
            }*/
        }

        static void CreateFactionSuccess(ref AddFactionMsg msg, MyNetworkClient sender)
        {
            MySession.Static.Factions.AddPlayerToFaction(msg.FounderId, msg.FactionId);
            MySession.Static.Factions.Add(new MyFaction(
                id:          msg.FactionId,
                tag:         msg.FactionTag,
                name:        msg.FactionName,
                desc:        msg.FactionDescription,
                privateInfo: msg.FactionPrivateInfo,
                creatorId:   msg.FounderId));

            foreach (var entry in MySession.Static.Factions)
            {
                var faction = entry.Value;
                faction.CancelJoinRequest(msg.FounderId);
            }

            var handler = MySession.Static.Factions.FactionCreated;

            if (handler != null)
                handler(msg.FactionId);
        }

        #endregion

        #region Serialization

        public MyObjectBuilder_FactionCollection GetObjectBuilder()
        {
            var builder = new MyObjectBuilder_FactionCollection();

            builder.Factions = new List<MyObjectBuilder_Faction>(m_factions.Count);
            foreach (var faction in m_factions)
                builder.Factions.Add(faction.Value.GetObjectBuilder());

            builder.Players = new SerializableDictionary<long, long>();
            foreach (var entry in m_playerFaction)
                builder.Players.Dictionary.Add(entry.Key, entry.Value);

            builder.Relations = new List<MyObjectBuilder_FactionRelation>(m_relationsBetweenFactions.Count);
            foreach (var entry in m_relationsBetweenFactions)
            {
                var relation = new MyObjectBuilder_FactionRelation();
                relation.FactionId1 = entry.Key.FactionId1;
                relation.FactionId2 = entry.Key.FactionId2;
                relation.Relation = entry.Value;
                builder.Relations.Add(relation);
            }

            builder.Requests = new List<MyObjectBuilder_FactionRequests>();
            foreach (var entryFrom in m_factionRequests)
            {
                var list = new List<long>(entryFrom.Value.Count);

                foreach (var entryTo in m_factionRequests[entryFrom.Key])
                    list.Add(entryTo);

                builder.Requests.Add(new MyObjectBuilder_FactionRequests() { FactionId = entryFrom.Key, FactionRequests = list });
            }

            return builder;
        }

        public void Init(MyObjectBuilder_FactionCollection builder)
        {
            if (!MySession.Static.Battle)
            {
                foreach (var factionBuilder in builder.Factions)
                    MySession.Static.Factions.Add(new MyFaction(factionBuilder));
            }

            foreach (var player in builder.Players.Dictionary)
                m_playerFaction.Add(player.Key, player.Value);

            foreach (var relation in builder.Relations)
                m_relationsBetweenFactions.Add(new MyFactionPair(relation.FactionId1, relation.FactionId2), relation.Relation);

            foreach (var request in builder.Requests)
            {
                var set = new HashSet<long>();

                foreach (var entry in request.FactionRequests)
                    set.Add(entry);

                m_factionRequests.Add(request.FactionId, set);
            }
        }

        #endregion

        #region Enumerable

        public MyFaction this[long factionId]
        {
            get { return m_factions[factionId]; }
        }

        public IEnumerator<KeyValuePair<long, MyFaction>> GetEnumerator()
        {
            return m_factions.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        IEnumerator<KeyValuePair<long, MyFaction>> IEnumerable<KeyValuePair<long, MyFaction>>.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion
    }
}
