using ProtoBuf;
using Sandbox.Common;
using Sandbox.Common.ObjectBuilders;
using Sandbox.Common.ObjectBuilders.Definitions;
using Sandbox.Engine.Multiplayer;
using Sandbox.Game.Entities;
using Sandbox.Game.World;
using SteamSDK;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using VRage.Serialization;
using Sandbox.ModAPI;
using Sandbox.Engine.Networking;
using VRage;
using Sandbox.Definitions;
using VRage.Game;
using VRage.Network;
using VRage.Game.ModAPI;

namespace Sandbox.Game.Multiplayer
{
    [StaticEventOwner]
    public partial class MyFactionCollection : IEnumerable<KeyValuePair<long, MyFaction>>
    {
        public enum MyFactionPeaceRequestState
        {
            None,
            Pending,
            Sent
        }

        public enum MyFactionStateChange
        {
            RemoveFaction,
            SendPeaceRequest,
            CancelPeaceRequest,
            AcceptPeace,
            DeclareWar,

            FactionMemberSendJoin,
            FactionMemberCancelJoin,
            FactionMemberAcceptJoin,
            FactionMemberKick,
            FactionMemberPromote,
            FactionMemberDemote,
            FactionMemberLeave
        }

        private struct MyFactionPair
        {
            public long FactionId1;
            public long FactionId2;

            public MyFactionPair(long id1, long id2)
            {
                FactionId1 = id1;
                FactionId2 = id2;
            }

            #region Comparer

            public class ComparerType : IEqualityComparer<MyFactionPair>
            {
                public bool Equals(MyFactionPair x, MyFactionPair y)
                {
                    return ((x.FactionId1 == y.FactionId1 && x.FactionId2 == y.FactionId2) ||
                            (x.FactionId1 == y.FactionId2 && x.FactionId2 == y.FactionId1));
                }

                public int GetHashCode(MyFactionPair obj)
                {
                    return obj.FactionId1.GetHashCode() ^ obj.FactionId2.GetHashCode();
                }
            }

            public static readonly ComparerType Comparer = new ComparerType();

            #endregion
        }

        [ProtoContract]
        struct AddFactionMsg
        {
            [ProtoMember]
            public long FounderId;
            /// <summary>
            /// Do not use this for request, this value is always generated by server!
            /// </summary>
            [ProtoMember]
            public long FactionId;
            [ProtoMember]
            public string FactionTag;
            [ProtoMember]
            public string FactionName;
            [Serialize(MyObjectFlags.Nullable)]
            [ProtoMember]
            public string FactionDescription;
            [ProtoMember]
            public string FactionPrivateInfo;
            [ProtoMember]
            public bool CreateFromDefinition;
        }

        /// <summary>
        /// All factions in a game.
        /// </summary>
        private Dictionary<long, MyFaction> m_factions = new Dictionary<long, MyFaction>();
        /// <summary>
        /// Ditto, indexed by their faction tag
        /// </summary>
        private Dictionary<string, MyFaction> m_factionsByTag = new Dictionary<string, MyFaction>();
        /// <summary>
        /// 
        /// </summary>
        private Dictionary<long, HashSet<long>> m_factionRequests = new Dictionary<long, HashSet<long>>();
        /// <summary>
        /// Relations between factions.
        /// </summary>
        private Dictionary<MyFactionPair, MyRelationsBetweenFactions> m_relationsBetweenFactions = new Dictionary<MyFactionPair, MyRelationsBetweenFactions>(MyFactionPair.Comparer);
        /// <summary>
        /// Player in faction dictionary.
        /// </summary>
        private Dictionary<long, long> m_playerFaction = new Dictionary<long, long>();

        /// <summary>
        /// Checks if faction exists.
        /// </summary>
        /// <param name="factionId">Faction id.</param>
        /// <returns>If true, faction exists.</returns>
        public bool Contains(long factionId)
        {
            return m_factions.ContainsKey(factionId);
        }

        public bool FactionTagExists(string tag, IMyFaction doNotCheck = null)
        {
            return TryGetFactionByTag(tag, doNotCheck) != null;
        }

        public bool FactionNameExists(string name, IMyFaction doNotCheck = null)
        {
            foreach (var entry in m_factions)
            {
                var faction = entry.Value;

                if (doNotCheck != null && doNotCheck.FactionId == faction.FactionId)
                    continue;

                if (string.Equals(name, faction.Name, StringComparison.OrdinalIgnoreCase))
                    return true;
            }
            return false;
        }

        public IMyFaction TryGetFactionById(long factionId)
        {
            MyFaction faction;
            if (m_factions.TryGetValue(factionId, out faction))
                return faction;
            return null;
        }

        public MyFaction TryGetOrCreateFactionByTag(string tag)
        {
            MyFaction faction = TryGetFactionByTag(tag);
            if (faction == null)
            {
                var upper = tag.ToUpperInvariant();
                var factionDef = MyDefinitionManager.Static.TryGetFactionDefinition(upper);
                if (factionDef == null)
                {
                    Debug.Assert(false, "Could not find a faction definition for the tag " + upper);
                    return null;
                }

                MyMultiplayer.RaiseStaticEvent(x => CreateFactionByDefinition, tag);
                faction = TryGetFactionByTag(tag);

            }
            return faction;
        }

        [Event, Reliable, Server]
        public static void CreateFactionByDefinition(string tag)
        {
            var upper = tag.ToUpperInvariant();

            if (MySession.Static.Factions.m_factionsByTag.ContainsKey(upper)) return;

            var factionDef = MyDefinitionManager.Static.TryGetFactionDefinition(upper);
            if (factionDef == null)
            {
                Debug.Assert(false, "Could not find a faction definition for the tag " + upper);
                return;
            }

            var founder = Sync.Players.CreateNewIdentity(factionDef.Founder);
            Sync.Players.MarkIdentityAsNPC(founder.IdentityId);
            
            var factionId = MyEntityIdentifier.AllocateId(MyEntityIdentifier.ID_OBJECT_TYPE.FACTION);
            CreateFactionServer(founder.IdentityId, upper, factionDef.DisplayNameText, factionDef.DescriptionText, "", factionDef);



        }

        /// <summary>
        /// Creates adds default factions to the faction collection.
        /// </summary>
        public void CreateDefaultFactions()
        {
            List<MyFactionDefinition> defaultFactions = MyDefinitionManager.Static.GetDefaultFactions();

            foreach(var faction in defaultFactions)
            {
                // Check if there is already one. If yes, don't recreate it.
                MyFaction oldFaction = this.TryGetFactionByTag(faction.Tag);
                if (oldFaction != null)
                    continue;

                // Create founder for the faction.
                var founder = Sync.Players.CreateNewIdentity(faction.Founder);
                if(founder == null)
                {
                    Debug.Assert(false, "Unable to create founder!");
                    continue;
                }
                Sync.Players.MarkIdentityAsNPC(founder.IdentityId);

                // Create faction with above founder.
                var factionId = MyEntityIdentifier.AllocateId(MyEntityIdentifier.ID_OBJECT_TYPE.FACTION);
                bool result = CreateFactionInternal(founder.IdentityId, factionId, faction);
                
                // If failed, remove owner.
                if (!result)
                {
                    Debug.Assert(false, "Could not create faction from definition");
                    Sync.Players.RemoveIdentity(founder.IdentityId);
                }
            }
        }

        public MyFaction TryGetFactionByTag(string tag, IMyFaction doNotCheck = null)
        {
            var upper = tag.ToUpperInvariant();
            MyFaction faction = null;
            m_factionsByTag.TryGetValue(upper, out faction);

            if (faction == null) return null;
            if (doNotCheck != null && faction.FactionId == doNotCheck.FactionId) return null;
            return faction;
        }

        private void UnregisterFactionTag(MyFaction faction)
        {
            Debug.Assert(faction != null, "Unregistering non-existent faction!");
            if (faction != null)
            {
                m_factionsByTag.Remove(faction.Tag.ToUpperInvariant());
            }
        }

        private void RegisterFactionTag(MyFaction faction)
        {
            Debug.Assert(faction != null, "Registering non-existent faction!");
            if (faction != null)
            {
                var upperTag = faction.Tag.ToUpperInvariant();
                MyFaction existingFaction = null;
                m_factionsByTag.TryGetValue(upperTag, out existingFaction);
                Debug.Assert(existingFaction == null, "Faction with the given tag already registered!");
                m_factionsByTag[upperTag] = faction;
            }
        }

        public IMyFaction TryGetPlayerFaction(long playerId)
        {
            if (m_playerFaction.ContainsKey(playerId) && m_factions.ContainsKey(m_playerFaction[playerId]))
                return m_factions[m_playerFaction[playerId]];

            return null;
        }

        public MyFaction GetPlayerFaction(long playerId)
        {
            if (m_playerFaction.ContainsKey(playerId) && m_factions.ContainsKey(m_playerFaction[playerId]))
                return m_factions[m_playerFaction[playerId]];

            return null;
        }

        public void AddPlayerToFaction(long playerId, long factionId)
        {
            AddPlayerToFactionInternal(playerId, factionId);
            foreach (var faction in m_factions)
                faction.Value.CancelJoinRequest(playerId);
        }

        // NOTE: Called by MyFaction to avoid premature deletion of join requests
        internal void AddPlayerToFactionInternal(long playerId, long factionId)
        {
            m_playerFaction[playerId] = factionId;
        }

        public void KickPlayerFromFaction(long playerId)
        {
            m_playerFaction.Remove(playerId);
        }

        /// <summary>
        /// Use this for quick check of relation between two factions.
        /// </summary>
        /// <param name="factionId1">First faction id</param>
        /// <param name="factionId2">Second faction id</param>
        /// <returns>Enum that describes the relation between given factions</returns>
        public MyRelationsBetweenFactions GetRelationBetweenFactions(long factionId1, long factionId2)
        {
            if (factionId1 == factionId2 && factionId1 != 0)
                return MyRelationsBetweenFactions.Neutral;

            var key = new MyFactionPair(factionId1, factionId2);

            if (m_relationsBetweenFactions.ContainsKey(key))
                return m_relationsBetweenFactions[key];

            return MyPerGameSettings.DefaultFactionRelationship;
        }

        public bool AreFactionsEnemies(long factionId1, long factionId2)
        {
            return GetRelationBetweenFactions(factionId1, factionId2) == MyRelationsBetweenFactions.Enemies;
        }

        public MyFactionPeaceRequestState GetRequestState(long myFactionId, long foreignFactionId)
        {
            if (m_factionRequests.ContainsKey(myFactionId) && m_factionRequests[myFactionId].Contains(foreignFactionId))
                return MyFactionPeaceRequestState.Sent;

            if (m_factionRequests.ContainsKey(foreignFactionId) && m_factionRequests[foreignFactionId].Contains(myFactionId))
                return MyFactionPeaceRequestState.Pending;

            return MyFactionPeaceRequestState.None;
        }

        public bool IsPeaceRequestStateSent(long myFactionId, long foreignFactionId)
        {
            return GetRequestState(myFactionId, foreignFactionId) == MyFactionPeaceRequestState.Sent;
        }

        public bool IsPeaceRequestStatePending(long myFactionId, long foreignFactionId)
        {
            return GetRequestState(myFactionId, foreignFactionId) == MyFactionPeaceRequestState.Pending;
        }


        public event Action<MyFactionStateChange, long, long, long, long> FactionStateChanged;

        public static void RemoveFaction(long factionId)
        {
            SendFactionChange(MyFactionStateChange.RemoveFaction, factionId, factionId, 0);
        }

        public static void SendPeaceRequest(long fromFactionId, long toFactionId)
        {
            SendFactionChange(MyFactionStateChange.SendPeaceRequest, fromFactionId, toFactionId, 0);
        }

        public static void CancelPeaceRequest(long fromFactionId, long toFactionId)
        {
            SendFactionChange(MyFactionStateChange.CancelPeaceRequest, fromFactionId, toFactionId, 0);
        }

        public static void AcceptPeace(long fromFactionId, long toFactionId)
        {
            SendFactionChange(MyFactionStateChange.AcceptPeace, fromFactionId, toFactionId, 0);
        }

        public static void DeclareWar(long fromFactionId, long toFactionId)
        {
            SendFactionChange(MyFactionStateChange.DeclareWar, fromFactionId, toFactionId, 0);
        }

        public static void SendJoinRequest(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberSendJoin, factionId, factionId, playerId);
        }

        public static void CancelJoinRequest(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberCancelJoin, factionId, factionId, playerId);
        }

        public static void AcceptJoin(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberAcceptJoin, factionId, factionId, playerId);
        }

        public static void KickMember(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberKick, factionId, factionId, playerId);
        }

        public static void PromoteMember(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberPromote, factionId, factionId, playerId);
        }

        public static void DemoteMember(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberDemote, factionId, factionId, playerId);
        }

        public static void MemberLeaves(long factionId, long playerId)
        {
            SendFactionChange(MyFactionStateChange.FactionMemberLeave, factionId, factionId, playerId);
        }

        bool CheckFactionStateChange(MyFactionStateChange action, long fromFactionId, long toFactionId, long playerId, long senderId)
        {
            Debug.Assert(Sync.IsServer, "Only server can check state of message!");
            if (!Sync.IsServer)
                return false;

            if (!m_factions.ContainsKey(fromFactionId) || !m_factions.ContainsKey(toFactionId))
                return false;

            var key = new MyFactionPair(fromFactionId, toFactionId);
            HashSet<long> tmpSet;

            switch (action)
            {
                case MyFactionStateChange.RemoveFaction: return true;

                case MyFactionStateChange.SendPeaceRequest:   return (!m_factionRequests.TryGetValue(fromFactionId, out tmpSet)) || !tmpSet.Contains(toFactionId);
                case MyFactionStateChange.CancelPeaceRequest: return (m_factionRequests.TryGetValue(fromFactionId, out tmpSet)) && tmpSet.Contains(toFactionId);

                case MyFactionStateChange.AcceptPeace: return GetRelationBetweenFactions(fromFactionId, toFactionId) != MyRelationsBetweenFactions.Neutral;
                case MyFactionStateChange.DeclareWar:  return GetRelationBetweenFactions(fromFactionId, toFactionId) != MyRelationsBetweenFactions.Enemies;

                case MyFactionStateChange.FactionMemberSendJoin:   return !m_factions[fromFactionId].IsMember(playerId)  && !m_factions[fromFactionId].JoinRequests.ContainsKey(playerId);
                case MyFactionStateChange.FactionMemberCancelJoin: return !m_factions[fromFactionId].IsMember(playerId)  &&  m_factions[fromFactionId].JoinRequests.ContainsKey(playerId);
                case MyFactionStateChange.FactionMemberAcceptJoin: return  m_factions[fromFactionId].JoinRequests.ContainsKey(playerId);
                case MyFactionStateChange.FactionMemberKick:       return  m_factions[fromFactionId].IsMember(playerId);
                case MyFactionStateChange.FactionMemberPromote:    return  m_factions[fromFactionId].IsMember(playerId);
                case MyFactionStateChange.FactionMemberDemote:     return  m_factions[fromFactionId].IsLeader(playerId);
                case MyFactionStateChange.FactionMemberLeave:      return  m_factions[fromFactionId].IsMember(playerId);
            }
            return false;
        }

        void ApplyFactionStateChange(MyFactionStateChange action, long fromFactionId, long toFactionId, long playerId, long senderId)
        {
            switch (action)
            {
                case MyFactionStateChange.RemoveFaction:
                    if (m_factions[fromFactionId].IsMember(MySession.Static.LocalPlayerId)) // kick all players from faction
                        m_playerFaction.Remove(playerId);

                    foreach (var faction in m_factions)
                    {
                        if (faction.Key != fromFactionId) // remove faction from neutrals and requests
                        {
                            ClearRequest(fromFactionId, faction.Key);
                            RemoveRelation(fromFactionId, faction.Key);
                        }
                    }

                    MyFaction toRemoveFaction = null;
                    var tag = m_factions.TryGetValue(fromFactionId, out toRemoveFaction);
                    UnregisterFactionTag(toRemoveFaction);

                    m_factions.Remove(fromFactionId);
                    break;

                case MyFactionStateChange.SendPeaceRequest:
                    HashSet<long> tmp;

                    if (m_factionRequests.TryGetValue(fromFactionId, out tmp))
                        tmp.Add(toFactionId);
                    else
                    {
                        tmp = new HashSet<long>();
                        tmp.Add(toFactionId);
                        m_factionRequests.Add(fromFactionId, tmp);
                    }
                    break;

                case MyFactionStateChange.CancelPeaceRequest:
                    ClearRequest(fromFactionId, toFactionId);
                    break;

                case MyFactionStateChange.AcceptPeace:
                    ClearRequest(fromFactionId, toFactionId);
                    ChangeRelation(fromFactionId, toFactionId, MyRelationsBetweenFactions.Neutral);
                    break;

                case MyFactionStateChange.DeclareWar:
                    ClearRequest(fromFactionId, toFactionId);
                    ChangeRelation(fromFactionId, toFactionId, MyRelationsBetweenFactions.Enemies);
                    break;

                case MyFactionStateChange.FactionMemberSendJoin:   m_factions[fromFactionId].AddJoinRequest(playerId); break;
                case MyFactionStateChange.FactionMemberCancelJoin: m_factions[fromFactionId].CancelJoinRequest(playerId); break;
                case MyFactionStateChange.FactionMemberAcceptJoin:
                    bool canAccept = false;
                    MyIdentity identity = MySession.Static.Players.TryGetIdentity(senderId);
                    MyPlayer player = identity != null ? MyPlayer.GetPlayerFromCharacter(identity.Character) : null;
                    if (player != null)
                        canAccept = MySession.Static.IsUserSpaceMaster(player.Client.SteamUserId);
                    if (canAccept && m_factions[fromFactionId].IsEveryoneNpc())
                    {
                        m_factions[fromFactionId].AcceptJoin(playerId, canAccept);
                        m_factions[fromFactionId].PromoteMember(playerId);
                    }
                    else
                        m_factions[fromFactionId].AcceptJoin(playerId, canAccept);
                    break;
                case MyFactionStateChange.FactionMemberLeave:
                case MyFactionStateChange.FactionMemberKick:    
                    m_factions[fromFactionId].KickMember(playerId);
                    if (Sync.IsServer && MySession.Static.Settings.ScenarioEditMode && Sync.Players.IdentityIsNpc(playerId))
                    {
                        MyIdentity id = Sync.Players.TryGetIdentity(playerId);
                        id.TransferAllBlocksTo(senderId);
                    }
                    break;
                case MyFactionStateChange.FactionMemberPromote: m_factions[fromFactionId].PromoteMember(playerId); break;
                case MyFactionStateChange.FactionMemberDemote:  m_factions[fromFactionId].DemoteMember(playerId); break;
            }
        }

        void ClearRequest(long fromFactionId, long toFactionId)
        {
            if (m_factionRequests.ContainsKey(fromFactionId))
                m_factionRequests[fromFactionId].Remove(toFactionId);

            if (m_factionRequests.ContainsKey(toFactionId))
                m_factionRequests[toFactionId].Remove(fromFactionId);
        }

        void ChangeRelation(long fromFactionId, long toFactionId, MyRelationsBetweenFactions relation)
        {
            m_relationsBetweenFactions[new MyFactionPair(fromFactionId, toFactionId)] = relation;
        }

        void RemoveRelation(long fromFactionId, long toFactionId)
        {
            m_relationsBetweenFactions.Remove(new MyFactionPair(fromFactionId, toFactionId));
        }

        static void SendFactionChange(MyFactionStateChange action, long fromFactionId, long toFactionId, long playerId)
        {
            MyMultiplayer.RaiseStaticEvent(s => MyFactionCollection.FactionStateChangeRequest, action, fromFactionId, toFactionId, playerId, MySession.Static.LocalPlayerId);
        }

        [Event, Reliable, Server]
        static void FactionStateChangeRequest(MyFactionStateChange action, long fromFactionId, long toFactionId, long playerId, long senderId)
        {
            var fromFaction = MySession.Static.Factions.TryGetFactionById(fromFactionId);
            var toFaction = MySession.Static.Factions.TryGetFactionById(toFactionId);

            if (fromFaction != null && toFaction != null &&
                MySession.Static.Factions.CheckFactionStateChange(action, fromFactionId, toFactionId, playerId, senderId))
            {
                if ((action == MyFactionStateChange.FactionMemberKick ||
                     action == MyFactionStateChange.FactionMemberLeave) && fromFaction.Members.Count() == 1)
                {
                    action = MyFactionStateChange.RemoveFaction;
                }
                else if (action == MyFactionStateChange.FactionMemberSendJoin)
                {
                    bool canAccept = false;
                    var identity = MySession.Static.Players.TryGetIdentity(senderId);
                    MyPlayer humanPlayer = null;
                    if (identity != null)
                    {
                        humanPlayer = MyPlayer.GetPlayerFromCharacter(identity.Character);
                        if (humanPlayer != null)
                            canAccept = MySession.Static.IsUserSpaceMaster(humanPlayer.Client.SteamUserId);
                    }
                    if (toFaction.AutoAcceptMember)
                    {
                        canAccept = true;
                        if (!toFaction.AcceptHumans)
                        {
                            // Check, whether the requesting player is human or bot
                            //I think this way the faction can accept dead character
                            if (humanPlayer != null && humanPlayer.Identity.IdentityId == playerId)
                            {
                                // You are a human. We dont like human!
                                canAccept = false;
                                action = MyFactionStateChange.FactionMemberCancelJoin;
                            }
                        }
                    }
                    if (canAccept)
                    {
                        action = MyFactionStateChange.FactionMemberAcceptJoin;
                        //senderId = 0; // no need to check who accepted this // no longer true because of SM ability to add NPC (replacement for ScenarioEditMode)
                    }
                }
                else if (action == MyFactionStateChange.SendPeaceRequest && toFaction.AutoAcceptPeace)
                {
                    action = MyFactionStateChange.AcceptPeace;
                    senderId = 0; // no need to check who accepted this
                }

                MyMultiplayer.RaiseStaticEvent(s => MyFactionCollection.FactionStateChangeSuccess, action, fromFactionId, toFactionId, playerId, senderId);
                FactionStateChangeSuccess(action, fromFactionId, toFactionId, playerId, senderId);
            }
        }

        [Event, Reliable, Broadcast]
        static void FactionStateChangeSuccess(MyFactionStateChange action, long fromFactionId, long toFactionId, long playerId, long senderId)
        {
            var fromFaction = MySession.Static.Factions.TryGetFactionById(fromFactionId);
            var toFaction = MySession.Static.Factions.TryGetFactionById(toFactionId);

            if (fromFaction != null && toFaction != null)
            {
                MySession.Static.Factions.ApplyFactionStateChange(action, fromFactionId, toFactionId, playerId, senderId);

                var handler = MySession.Static.Factions.FactionStateChanged;

                if (handler != null)
                    handler(action, fromFactionId, toFactionId, playerId, senderId);
            }
        }

        internal List<MyObjectBuilder_Faction> SaveFactions()
        {
            List<MyObjectBuilder_Faction> factionBuilders = new List<MyObjectBuilder_Faction>();
            foreach (var factionPair in m_factions)
            {
                MyObjectBuilder_Faction ob = factionPair.Value.GetObjectBuilder();
                factionBuilders.Add(ob);
            }

            return factionBuilders;
        }

        internal void LoadFactions(List<MyObjectBuilder_Faction> factionBuilders, bool removeOldData = true)
        {
            if (removeOldData)
            {
                m_factions.Clear();
                m_factionRequests.Clear();
                m_relationsBetweenFactions.Clear();
                m_playerFaction.Clear();
                m_factionsByTag.Clear();
            }

            if (factionBuilders == null)
                return;

            foreach (var builder in factionBuilders) 
            {
                if (m_factions.ContainsKey(builder.FactionId))
                    continue;

                var faction = new MyFaction(builder);
                Add(faction);

                // Must initialize also m_playerFaction
                foreach (var member in faction.Members)
                {
                    AddPlayerToFaction(member.Value.PlayerId, faction.FactionId);
                }
            }
        }


        #region Change Faction AutoAccept

        public event Action<long, bool, bool> FactionAutoAcceptChanged;

        public void ChangeAutoAccept(long factionId, long playerId, bool autoAcceptMember, bool autoAcceptPeace)
        {
            MyMultiplayer.RaiseStaticEvent(s => MyFactionCollection.ChangeAutoAcceptRequest, factionId, playerId, autoAcceptMember, autoAcceptPeace);
        }

        [Event, Reliable, Server]
        static void ChangeAutoAcceptRequest(long factionId, long playerId, bool autoAcceptMember, bool autoAcceptPeace)
        {
            var faction = MySession.Static.Factions.TryGetFactionById(factionId);

            if (faction != null && faction.IsLeader(playerId))
            {
                MyMultiplayer.RaiseStaticEvent(s => MyFactionCollection.ChangeAutoAcceptSuccess, factionId, autoAcceptMember, autoAcceptPeace);
            }
        }

        [Event, Reliable, Server, Broadcast]
        static void ChangeAutoAcceptSuccess(long factionId, bool autoAcceptMember, bool autoAcceptPeace)
        {
            MySession.Static.Factions[factionId].AutoAcceptMember = autoAcceptMember;
            MySession.Static.Factions[factionId].AutoAcceptPeace = autoAcceptPeace;

            var handler = MySession.Static.Factions.FactionAutoAcceptChanged;

            if (handler != null)
                handler(factionId, autoAcceptMember, autoAcceptPeace);
        }

        #endregion

        #region Edit Faction

        public event Action<long> FactionEdited;

        public void EditFaction(long factionId, string tag, string name, string desc, string privateInfo)
        {
            MyMultiplayer.RaiseStaticEvent(s => MyFactionCollection.EditFactionRequest, factionId, tag, name, desc, privateInfo);
        }

        [Event, Reliable, Server]
        static void EditFactionRequest(long factionId, string tag, string name, [Serialize(MyObjectFlags.Nullable)]string desc, string privateInfo)
        {
            var faction = MySession.Static.Factions.TryGetFactionById(factionId);

            if (faction != null && !MySession.Static.Factions.FactionTagExists(tag, faction) && !MySession.Static.Factions.FactionNameExists(name, faction))
            {
                MyMultiplayer.RaiseStaticEvent(s => MyFactionCollection.EditFactionSuccess, factionId, tag, name, desc, privateInfo);
            }
        }

        [Event, Reliable, Server, Broadcast]
        static void EditFactionSuccess(long factionId, string tag, string name, [Serialize(MyObjectFlags.Nullable)]string desc, string privateInfo)
        {
            var faction = MySession.Static.Factions.TryGetFactionById(factionId) as MyFaction;
            Debug.Assert(faction != null, "Editing a non-existent faction!");
            if (faction == null) return;

            MySession.Static.Factions.UnregisterFactionTag(faction);

            faction.Tag = tag;
            faction.Name = name;
            faction.Description = desc;
            faction.PrivateInfo = privateInfo;

            MySession.Static.Factions.RegisterFactionTag(faction);

            var handler = MySession.Static.Factions.FactionEdited;

            if (handler != null)
                handler(factionId);
        }

        #endregion

        #region Create Faction

        public event Action<long> FactionCreated;

        public void CreateFaction(long founderId, string tag, string name, string desc, string privateInfo)
        {
            SendCreateFaction(founderId, tag, name, desc, privateInfo);
        }

        void Add(MyFaction faction)
        {
            m_factions.Add(faction.FactionId, faction);
            RegisterFactionTag(faction);
        }

        void SendCreateFaction(long founderId, string factionTag, string factionName, string factionDesc, string factionPrivate)
        {
            var msg                = new AddFactionMsg();
            msg.FounderId          = founderId;
            msg.FactionTag         = factionTag;
            msg.FactionName        = factionName;
            msg.FactionDescription = factionDesc;
            msg.FactionPrivateInfo = factionPrivate;

            MyMultiplayer.RaiseStaticEvent(s => MyFactionCollection.CreateFactionRequest, msg);
        }

        [Event, Reliable, Server]
        static void CreateFactionRequest(AddFactionMsg msg)
        {
            CreateFactionServer(msg.FounderId, msg.FactionTag, msg.FactionName, msg.FactionDescription, msg.FactionPrivateInfo);
        }

        /// <summary>
        /// Creates faction on server and sends message to client to create one there. If faction definition is provided than faction will be created from definition and
        /// faction name, description and private info will be taken from definition.
        /// </summary>
        /// <param name="founderId">Founder id</param>
        /// <param name="factionTag">Faction tag</param>
        /// <param name="factionName">Faction name</param>
        /// <param name="description">Faction Description</param>
        /// <param name="privateInfo">Private info</param>
        /// <param name="factionDef">Optional: faction definition.</param>
        private static void CreateFactionServer(long founderId, string factionTag, string factionName, string description, string privateInfo, MyFactionDefinition factionDef = null)
        {
            Debug.Assert(Sync.IsServer, "Faction ID can only be allocated on the server!");
            if (!Sync.IsServer) return;

            long factionId = MyEntityIdentifier.AllocateId(MyEntityIdentifier.ID_OBJECT_TYPE.FACTION);
            var faction = MySession.Static.Factions.TryGetFactionById(factionId);
            var senderFaction = MySession.Static.Factions.TryGetPlayerFaction(founderId);

            if (senderFaction == null && faction == null
                && !MySession.Static.Factions.FactionTagExists(factionTag)
                && !MySession.Static.Factions.FactionNameExists(factionName)
                && Sync.Players.HasIdentity(founderId))
            {
                bool createFromDef = factionDef == null ? false : true;

                if (createFromDef)
                    CreateFactionInternal(founderId, factionId, factionDef);
                else
                    CreateFactionInternal(founderId, factionId, factionTag, factionName, description, privateInfo);


                AddFactionMsg newMsg = new AddFactionMsg();
                newMsg.FactionId = factionId;
                newMsg.FounderId = founderId;
                newMsg.FactionTag = factionTag;
                newMsg.FactionName = factionName;
                newMsg.FactionDescription = description;
                newMsg.FactionPrivateInfo = privateInfo;
                newMsg.CreateFromDefinition = createFromDef;

                MyMultiplayer.RaiseStaticEvent(x => CreateFactionSuccess, newMsg);

                // Call myself.
                SetDefaultFactionStates(factionId);
                // Call everyone else.
                MyMultiplayer.RaiseStaticEvent(x => SetDefaultFactionStates, factionId);

            }
        }

        [Event, Reliable, Broadcast]
        static void CreateFactionSuccess(AddFactionMsg msg)
        {
            if (msg.CreateFromDefinition)
            {
                var factionDef = MyDefinitionManager.Static.TryGetFactionDefinition(msg.FactionTag);
                if (factionDef == null)
                {
                    Debug.Assert(false, "Could not find a faction definition for the tag " + msg.FactionTag);
                    return;
                }

                CreateFactionInternal(msg.FounderId, msg.FactionId, factionDef);
            }
            else
                CreateFactionInternal(msg.FounderId, msg.FactionId, msg.FactionTag, msg.FactionName, msg.FactionDescription, msg.FactionPrivateInfo);
        }

        /// <summary>
        /// Creates faction from definition.
        /// </summary>
        /// <param name="founderId">Identity id of the owner.</param>
        /// <param name="factionId">Faction id to be used for the faction.</param>
        /// <param name="factionDef">Faction definition.</param>
        /// <returns>If true than faction was created.</returns>
        private static bool CreateFactionInternal(long founderId, long factionId, MyFactionDefinition factionDef)
        {
            if (MySession.Static.Factions.Contains(factionId))
                return false;

            var newFaction = new MyFaction(
                id: factionId,
                tag: factionDef.Tag,
                name: factionDef.DisplayNameText,
                desc: factionDef.DescriptionText,
                privateInfo: "",
                creatorId: founderId);
            MySession.Static.Factions.Add(newFaction);

            MySession.Static.Factions.AddPlayerToFaction(founderId, factionId);

            newFaction.AcceptHumans = factionDef.AcceptHumans;
            newFaction.AutoAcceptMember = factionDef.AutoAcceptMember;
            newFaction.EnableFriendlyFire = factionDef.EnableFriendlyFire;

            AfterFactionCreated(founderId, factionId);

            return true;
        }

        private static void CreateFactionInternal(long founderId, long factionId, string factionTag, string factionName, string factionDescription, string factionPrivateInfo)
        {
            MySession.Static.Factions.AddPlayerToFaction(founderId, factionId);
            MySession.Static.Factions.Add(new MyFaction(
                id: factionId,
                tag: factionTag,
                name: factionName,
                desc: factionDescription,
                privateInfo: factionPrivateInfo,
                creatorId: founderId));

            AfterFactionCreated(founderId, factionId);
        }

        /// <summary>
        /// Determines what kind of faction change request should be used depending on default faction
        /// relation to other ones.
        /// </summary>
        /// <returns></returns>
        private static MyFactionStateChange DetermineRequestFromRelation(MyRelationsBetweenFactions relation)
        {
            MyFactionStateChange stateChange;
            if (relation == MyRelationsBetweenFactions.Enemies)
            {
                stateChange = MyFactionStateChange.DeclareWar;
            }
            else
            {
                stateChange = MyFactionStateChange.SendPeaceRequest;
            }

            return stateChange;
        }

        private static void AfterFactionCreated(long founderId, long factionId)
        {
            foreach (var entry in MySession.Static.Factions)
            {
                var faction = entry.Value;
                faction.CancelJoinRequest(founderId);
            }

            var handler = MySession.Static.Factions.FactionCreated;

            if (handler != null)
                handler(factionId);
        }

        [Event,Reliable, Broadcast]
        private static void SetDefaultFactionStates(long recivedFactionId)
        {
            IMyFaction recievedFaction = MySession.Static.Factions.TryGetFactionById(recivedFactionId);
            MyFactionDefinition recievedFactionDefiniton = MyDefinitionManager.Static.TryGetFactionDefinition(recievedFaction.Tag);

            foreach (var factionPair in MySession.Static.Factions)
            {
                MyFaction faction = factionPair.Value;

                if (faction.FactionId == recivedFactionId)
                    continue;

                if (recievedFactionDefiniton != null) // If I have definition, force my relations on everyone.
                {
                    SetDefaultFactionStateInternal(faction.FactionId, recievedFaction, recievedFactionDefiniton);
                }
                else // Otherwise search for default factions and set their relations on me.
                {
                    MyFactionDefinition factionDefiniton = MyDefinitionManager.Static.TryGetFactionDefinition(faction.Tag);
                    if (factionDefiniton == null)
                        continue;

                    SetDefaultFactionStateInternal(recivedFactionId, faction, factionDefiniton);
                }
            }

            

        }

        /// <summary>
        /// Sets default faction relation on provided faction.
        /// </summary>
        /// <param name="factionId">Faction on which set the default faction relations.</param>
        /// <param name="defaultFaction">Default faction which contains definition of the relation.</param>
        /// <param name="defaultFactionDef">Default faction definition.</param>
        private static void SetDefaultFactionStateInternal(long factionId, IMyFaction defaultFaction, MyFactionDefinition defaultFactionDef)
        {
            MyFactionStateChange stateChange = DetermineRequestFromRelation(defaultFactionDef.DefaultRelation);
            MySession.Static.Factions.ApplyFactionStateChange(stateChange, defaultFaction.FactionId, factionId, defaultFaction.FounderId, defaultFaction.FounderId);
            
            var handler = MySession.Static.Factions.FactionStateChanged;

            if (handler != null)
                handler(stateChange, defaultFaction.FactionId, factionId, defaultFaction.FounderId, defaultFaction.FounderId);
        }


        #endregion

        #region Serialization

        public MyObjectBuilder_FactionCollection GetObjectBuilder()
        {
            var builder = new MyObjectBuilder_FactionCollection();

            builder.Factions = new List<MyObjectBuilder_Faction>(m_factions.Count);
            foreach (var faction in m_factions)
                builder.Factions.Add(faction.Value.GetObjectBuilder());

            builder.Players = new SerializableDictionary<long, long>();
            foreach (var entry in m_playerFaction)
                builder.Players.Dictionary.Add(entry.Key, entry.Value);

            builder.Relations = new List<MyObjectBuilder_FactionRelation>(m_relationsBetweenFactions.Count);
            foreach (var entry in m_relationsBetweenFactions)
            {
                var relation = new MyObjectBuilder_FactionRelation();
                relation.FactionId1 = entry.Key.FactionId1;
                relation.FactionId2 = entry.Key.FactionId2;
                relation.Relation = entry.Value;
                builder.Relations.Add(relation);
            }

            builder.Requests = new List<MyObjectBuilder_FactionRequests>();
            foreach (var entryFrom in m_factionRequests)
            {
                var list = new List<long>(entryFrom.Value.Count);

                foreach (var entryTo in m_factionRequests[entryFrom.Key])
                    list.Add(entryTo);

                builder.Requests.Add(new MyObjectBuilder_FactionRequests() { FactionId = entryFrom.Key, FactionRequests = list });
            }

            return builder;
        }

        public void Init(MyObjectBuilder_FactionCollection builder)
        {
            foreach (var factionBuilder in builder.Factions)
                MySession.Static.Factions.Add(new MyFaction(factionBuilder));

            foreach (var player in builder.Players.Dictionary)
                m_playerFaction.Add(player.Key, player.Value);

            foreach (var relation in builder.Relations)
                m_relationsBetweenFactions.Add(new MyFactionPair(relation.FactionId1, relation.FactionId2), relation.Relation);

            foreach (var request in builder.Requests)
            {
                var set = new HashSet<long>();

                foreach (var entry in request.FactionRequests)
                    set.Add(entry);

                m_factionRequests.Add(request.FactionId, set);
            }
        }

        #endregion

        #region Enumerable

        public MyFaction this[long factionId]
        {
            get { return m_factions[factionId]; }
        }

        public IEnumerator<KeyValuePair<long, MyFaction>> GetEnumerator()
        {
            return m_factions.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        IEnumerator<KeyValuePair<long, MyFaction>> IEnumerable<KeyValuePair<long, MyFaction>>.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion
    }
}
